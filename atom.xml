<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小贺今天有认真学习吗</title>
  
  <subtitle>昨日恍如隔世，少年砥砺向前</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hoyyy.com/"/>
  <updated>2019-08-21T15:56:16.468Z</updated>
  <id>http://hoyyy.com/</id>
  
  <author>
    <name>Yaron Ho</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT甲级 1062. Talent and Virtue</title>
    <link href="http://hoyyy.com/2019/08/21/PAT%E7%94%B2%E7%BA%A7-1062-Talent-and-Virtue/"/>
    <id>http://hoyyy.com/2019/08/21/PAT甲级-1062-Talent-and-Virtue/</id>
    <published>2019-08-21T15:25:32.000Z</published>
    <updated>2019-08-21T15:56:16.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一个第二道题，分值25分，麻烦就在于题目信息量大，需要细心整理，算法主要就是需要大量自定义排序，需要小心谨慎处理边界条件。</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people’s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a “sage（圣人）”; being less excellent but with one’s virtue outweighs talent can be called a “nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man is better than a “small man（小人）” who prefers talent than virtue.</p><p>Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang’s theory.</p><p>Input Specification:<br>Each input file contains one test case. Each case first gives 3 positive integers in a line: N (≤10^​5), the total number of people to be ranked; L (≥60), the lower bound of the qualified grades – that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and H (\&lt;100), the higher line of qualification – that is, those with both grades not below this line are considered as the “sages”, and will be ranked in non-increasing order according to their total grades. Those with talent grades below H but virtue grades not are cosidered as the “noblemen”, and are also ranked in non-increasing order according to their total grades, but they are listed after the “sages”. Those with both grades below H, but with virtue not lower than talent are considered as the “fool men”. They are ranked in the same way but after the “noblemen”. The rest of people whose grades both pass the L line are ranked after the “fool men”.</p><p>Then N lines follow, each gives the information of a person in the format:</p><p>ID_Number Virtue_Grade Talent_Grade<br>where ID_Number is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space.</p><p>Output Specification:<br>The first line of output must give M (≤N), the total number of people that are actually ranked. Then M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID’s.</p><p>Sample Input:<br>14 60 80<br>10000001 64 90<br>10000002 90 60<br>10000011 85 80<br>10000003 85 80<br>10000004 80 85<br>10000005 82 77<br>10000006 83 76<br>10000007 90 78<br>10000008 75 79<br>10000009 59 90<br>10000010 88 45<br>10000012 80 100<br>10000013 90 99<br>10000014 66 60</p><p>Sample Output:<br>12<br>10000013 90 99<br>10000012 80 100<br>10000003 85 80<br>10000011 85 80<br>10000004 80 85<br>10000007 90 78<br>10000006 83 76<br>10000005 82 77<br>10000002 90 60<br>10000014 66 60<br>10000008 75 79<br>10000001 64 90</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这个就是按照题目给定的优先级自定义排序，需要会最基本的自定义排序，然后仔细确定优先级，不要急就行。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, L, H;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, v, t;</span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : id(a), v(b), t(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Person *a, Person *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;v &gt;= H &amp;&amp; a-&gt;t &gt;= H) &#123;    <span class="comment">// a is in level 1</span></span><br><span class="line">        <span class="keyword">if</span>(b-&gt;v &gt;= H &amp;&amp; b-&gt;t &gt;= H) &#123;    <span class="comment">// b is in level 1</span></span><br><span class="line">            <span class="keyword">if</span>(a-&gt;v + a-&gt;t == b-&gt;v + b-&gt;t) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a-&gt;v == b-&gt;v) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a-&gt;id &lt; b-&gt;id;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a-&gt;v &gt; b-&gt;v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (a-&gt;v + a-&gt;t) &gt; (b-&gt;v + b-&gt;t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// b is not in level 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;v &gt;= H &amp;&amp; a-&gt;t &lt; H) &#123;    <span class="comment">// a is in level 2</span></span><br><span class="line">        <span class="keyword">if</span>(b-&gt;v &gt;= H &amp;&amp; b-&gt;t &gt;= H) &#123;    <span class="comment">// b is in level 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;v &gt;= H &amp;&amp; b-&gt;t &lt; H) &#123;    <span class="comment">// b is in level 2</span></span><br><span class="line">            <span class="keyword">if</span>(a-&gt;v + a-&gt;t == b-&gt;v + b-&gt;t) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a-&gt;v == b-&gt;v) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a-&gt;id &lt; b-&gt;id;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a-&gt;v &gt; b-&gt;v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (a-&gt;v + a-&gt;t) &gt; (b-&gt;v + b-&gt;t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;v &lt; H &amp;&amp; a-&gt;t &lt; H &amp;&amp; a-&gt;v &gt;= a-&gt;t) &#123;    <span class="comment">//a is in level 3</span></span><br><span class="line">        <span class="keyword">if</span>(b-&gt;v &gt;= H) &#123;    <span class="comment">// b is in level 1 or level 2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;v &lt; H &amp;&amp; b-&gt;t &lt; H &amp;&amp; b-&gt;v &gt;= b-&gt;t) &#123;    <span class="comment">// b is in level 3</span></span><br><span class="line">            <span class="keyword">if</span>(a-&gt;v + a-&gt;t == b-&gt;v + b-&gt;t) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a-&gt;v == b-&gt;v) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a-&gt;id &lt; b-&gt;id;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a-&gt;v &gt; b-&gt;v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (a-&gt;v + a-&gt;t) &gt; (b-&gt;v + b-&gt;t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// a is in level 4</span></span><br><span class="line">        <span class="keyword">if</span>(b-&gt;v &gt;= H || (b-&gt;v &lt; H &amp;&amp; b-&gt;t &lt; H &amp;&amp; b-&gt;v &gt;= b-&gt;t)) &#123;    <span class="comment">// b is in level 1,2,3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// b is in level 4</span></span><br><span class="line">            <span class="keyword">if</span>(a-&gt;v + a-&gt;t == b-&gt;v + b-&gt;t) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a-&gt;v == b-&gt;v) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a-&gt;id &lt; b-&gt;id;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a-&gt;v &gt; b-&gt;v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (a-&gt;v + a-&gt;t) &gt; (b-&gt;v + b-&gt;t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;N, &amp;L, &amp;H);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person*&gt; people;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(b &gt;= L &amp;&amp; c &gt;= L) &#123;</span><br><span class="line">            Person *newPerson = <span class="keyword">new</span> Person(a, b, c);</span><br><span class="line">            people.push_back(newPerson);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">    sort(people.begin(), people.end(), cmp);</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; people.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; people[i]-&gt;id &lt;&lt; <span class="string">" "</span> &lt;&lt; people[i]-&gt;v &lt;&lt; <span class="string">" "</span> &lt;&lt; people[i]-&gt;t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个题目没有耐心的话就很容易出错，这种题就不要急着先动手，而是把逻辑流程图全部仔细写好，然后再编程，不然后期调试很浪费时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是一个第二道题，分值25分，麻烦就在于题目信息量大，需要细心整理，算法主要就是需要大量自定义排序，需要小心谨慎处理边界条件。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="PAT" scheme="http://hoyyy.com/categories/PAT/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="Sort" scheme="http://hoyyy.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级 1061. Dating</title>
    <link href="http://hoyyy.com/2019/08/21/PAT%E7%94%B2%E7%BA%A7-1061-Dating/"/>
    <id>http://hoyyy.com/2019/08/21/PAT甲级-1061-Dating/</id>
    <published>2019-08-21T15:24:39.000Z</published>
    <updated>2019-08-21T15:54:53.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个题目不难，是第一道题，稳中求进。这个题目麻烦一点的在于题目的意思我感觉有一点含糊不清，我一开始就是可能误解题目意思了导致条件有疏忽。</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>Sherlock Holmes received a note with some strange strings: Let’s date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm. It took him only a minute to figure out that those strange strings are actually referring to the coded time Thursday 14:04 – since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter D, representing the 4th day in a week; the second common character is the 5th capital letter E, representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N, respectively); and the English letter shared by the last two strings is s at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time.</p><p>Input Specification:<br>Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines.</p><p>Output Specification:<br>For each test case, print the decoded time in one line, in the format DAY HH:MM, where DAY is a 3-character abbreviation for the days in a week – that is, MON for Monday, TUE for Tuesday, WED for Wednesday, THU for Thursday, FRI for Friday, SAT for Saturday, and SUN for Sunday. It is guaranteed that the result is unique for each case.</p><p>Sample Input:<br>3485djDkxh4hhGE<br>2984akDfkkkkggEdsb<br>s&amp;hgsfdk<br>d&amp;Hyscvnm</p><p>Sample Output:<br>THU 14:04</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>题目大概是给定四个字符串，然后给出一个时间点。</p><p>第一个信息点是要破译出星期几。根据例子，前两个字符串中第一次出现同位相同的字母时，如果这个字母是A到G中的一个，就说明它在这几个字母中的顺序就是一周中的第几天，比如D是第四位，那么就代表星期四。</p><p>第二个信息点是要破译出第几小时。它提到第二个在同一位置相同的字母是E，代表14，因为0到9代表了零点到九点，而从A开始到N就是代表十点到二十三点。题目中这个相同的E是出现在前两个字符串中的，它没提及到是否有可能前两个中可能不存在，那么是不是要在后两个字符串中去找，因为这涉及到第三个信息点。</p><p>第三个信息点是，后两个字符串中如果在同一个位置出现了s这个字母，注意只认s这个字母，然后它在后两个字符串中的位置（从0开始）是4，那么就是代表第四分钟。似乎可以知道了，如果前两个字符串中没有找到小时的破译点（也就是第二对相同位置的相同字母且在A和N之间），那么就在后两个字符串中去找。由于分钟的定义不是后两个字符串中相同位置的相同字母给出，而是固定的s的位置给出，那么就不会和第二个信息点发生冲突。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2, s3, s4;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; commons;</span><br><span class="line">    <span class="keyword">int</span> M;</span><br><span class="line"><span class="comment">// 找到第一个信息点以及可能存在的第二个信息点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min(s1.size(), s2.size()); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] == s2[i]) &#123;</span><br><span class="line">            commons.push_back(s1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min(s3.size(), s4.size()); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s3[i] == s4[i]) &#123;</span><br><span class="line">            commons.push_back(s3[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; min(s3.size(), s4.size()); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s3[i] == s4[i] &amp;&amp; <span class="built_in">isalpha</span>(s3[i])) &#123;</span><br><span class="line">            M = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> D, H;</span><br><span class="line">    <span class="keyword">bool</span> isDFind = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commons.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isDFind) &#123;</span><br><span class="line">            <span class="keyword">if</span>(commons[i] &lt;= <span class="string">'G'</span> &amp;&amp; commons[i] &gt;= <span class="string">'A'</span>) &#123;</span><br><span class="line">                D = commons[i];</span><br><span class="line">                isDFind = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(commons[i] &gt;= <span class="string">'0'</span> &amp;&amp; commons[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                H = commons[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(commons[i] &gt;= <span class="string">'A'</span> &amp;&amp; commons[i] &lt;= <span class="string">'N'</span>) &#123;</span><br><span class="line">                H = commons[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'A'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"MON "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(D == <span class="string">'B'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TUE "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(D == <span class="string">'C'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WED "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(D == <span class="string">'D'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"THU "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(D == <span class="string">'E'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"FRI "</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(D == <span class="string">'F'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SAT "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(D == <span class="string">'G'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SUN "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> Hi;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(H)) &#123;</span><br><span class="line">        Hi = (<span class="keyword">int</span>)(H - <span class="string">'0'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Hi = (<span class="keyword">int</span>)(H - <span class="string">'A'</span> + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:"</span>, Hi);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d"</span>, M);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我这个写复杂了，当时AC了就没管了，还可以简化的，确实有点不优雅…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这个题目不难，是第一道题，稳中求进。这个题目麻烦一点的在于题目的意思我感觉有一点含糊不清，我一开始就是可能误解题目意思了导致条件有疏忽。&lt;/
      
    
    </summary>
    
      <category term="PAT" scheme="http://hoyyy.com/categories/PAT/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="String" scheme="http://hoyyy.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级 1153. Decode Registration Card of PAT</title>
    <link href="http://hoyyy.com/2019/08/21/PAT%E7%94%B2%E7%BA%A7-1153-Decode-Registration-Card-of-PAT/"/>
    <id>http://hoyyy.com/2019/08/21/PAT甲级-1153-Decode-Registration-Card-of-PAT/</id>
    <published>2019-08-21T14:47:56.000Z</published>
    <updated>2019-08-21T15:22:54.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是第二道题25分类型，这个题文字有点多，一定要细心看清题目的要求。这类模拟题难就难在信息量多，容易忽略很多小细节，算法上没有难处。不过我在这题犯了一些低级错误，还是题目量不够啊。</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>A registration card number of PAT consists of 4 parts:</p><p>the 1st letter represents the test level, namely, T for the top level, A for advance and B for basic;<br>the 2nd - 4th digits are the test site number, ranged from 101 to 999;<br>the 5th - 10th digits give the test date, in the form of yymmdd;<br>finally the 11th - 13th digits are the testee’s number, ranged from 000 to 999.<br>Now given a set of registration card numbers and the scores of the card owners, you are supposed to output the various statistics according to the given queries.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line gives two positive integers N (≤10^4) and M (≤100), the numbers of cards and the queries, respectively.</p><p>Then N lines follow, each gives a card number and the owner’s score (integer in [0, 100]), separated by a space.</p><p>After the info of testees, there are M lines, each gives a query in the format Type Term, where</p><p>Type being 1 means to output all the testees on a given level, in non-increasing order of their scores. The corresponding Term will be the letter which specifies the level;<br>Type being 2 means to output the total number of testees together with their total scores in a given site. The corresponding Term will then be the site number;<br>Type being 3 means to output the total number of testees of every site for a given test date. The corresponding Term will then be the date, given in the same format as in the registration card.<br>Output Specification:<br>For each query, first print in a line Case #: input, where # is the index of the query case, starting from 1; and input is a copy of the corresponding input query. Then output as requested:</p><p>for a type 1 query, the output format is the same as in input, that is, CardNumber Score. If there is a tie of the scores, output in increasing alphabetical order of their card numbers (uniqueness of the card numbers is guaranteed);<br>for a type 2 query, output in the format Nt Ns where Nt is the total number of testees and Ns is their total score;<br>for a type 3 query, output in the format Site Nt where Site is the site number and Nt is the total number of testees at Site. The output must be in non-increasing order of Nt’s, or in increasing order of site numbers if there is a tie of Nt.<br>If the result of a query is empty, simply print NA.</p><p>Sample Input:<br>8 4<br>B123180908127 99<br>B102180908003 86<br>A112180318002 98<br>T107150310127 62<br>A107180908108 100<br>T123180908010 78<br>B112160918035 88<br>A107180908021 98<br>1 A<br>2 107<br>3 180908<br>2 999</p><p>Sample Output:<br>Case 1: 1 A<br>A107180908108 100<br>A107180908021 98<br>A112180318002 98<br>Case 2: 2 107<br>3 260<br>Case 3: 3 180908<br>107 2<br>123 2<br>102 1<br>Case 4: 2 999<br>NA</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>首先根据每个考生建立一个结构体，两个成员，分别是ID和分数。然后设置一个存储所有考生的vector，我因为习惯用指针来存储结构体，所以我这个vector存的是指针类型。</p><p>然后根据三类不同的查询写三个不同的函数。</p><p>第一类把符合查询要求的考生单独建立一个子集，然后根据要求排序输出即可，没有的情况下就输出NA。</p><p>第二类设置两个变量分别记录符合要求的学生总数和其分数总和，然后遍历所有考生，按条件对两个变量进行增量。如果学生人数为零，则输出NA。</p><p>第三类则用一个map存储 地点-人数 对，但是由于有一个case超时无法通过，在参考柳诺的博客之后，了解到map是红黑树实现的，unordered_map是散列表实现的，意味着后者的查询效率要高很多。所以将map替换为unordered_map。然后将其转换为vector按题目要求进行排序即可。然后按序输出，如果map是空的就输出NA。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Testee</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> ID;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">Testee(<span class="built_in">string</span> id, <span class="keyword">int</span> s) : ID(id), score(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Testee *&gt; testees;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareByScore</span><span class="params">(Testee * <span class="keyword">const</span> &amp;a, Testee * <span class="keyword">const</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;score == b-&gt;score) &#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;ID &lt; b-&gt;ID;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;score &gt; b-&gt;score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queryOne</span><span class="params">(<span class="built_in">string</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Testee *&gt; subTestees;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testees.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((testees[i]-&gt;ID).substr(<span class="number">0</span>, <span class="number">1</span>) == level) &#123;</span><br><span class="line">            subTestees.push_back(testees[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(subTestees.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sort(subTestees.begin(), subTestees.end(), compareByScore);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; subTestees.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, subTestees[i]-&gt;ID.c_str(), subTestees[i]-&gt;score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queryTwo</span><span class="params">(<span class="built_in">string</span> site)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Nt = <span class="number">0</span>, Ns = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testees.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((testees[i]-&gt;ID).substr(<span class="number">1</span>, <span class="number">3</span>) == site) &#123;</span><br><span class="line">            Nt++;</span><br><span class="line">            Ns += testees[i]-&gt;score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(Nt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Nt, Ns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareByNt</span><span class="params">(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp;a, pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second == b.second) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queryThree</span><span class="params">(<span class="built_in">string</span> date)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; siteNtMap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testees.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((testees[i]-&gt;ID).substr(<span class="number">4</span>, <span class="number">6</span>) == date) &#123;</span><br><span class="line">            siteNtMap[(testees[i]-&gt;ID).substr(<span class="number">1</span>, <span class="number">3</span>)]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(siteNtMap.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; siteNtVec(siteNtMap.begin(), siteNtMap.end());</span><br><span class="line">        sort(siteNtVec.begin(), siteNtVec.end(), compareByNt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siteNtVec.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, siteNtVec[i].first.c_str(), siteNtVec[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ID;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ID &gt;&gt; score;</span><br><span class="line">        Testee *testee = <span class="keyword">new</span> Testee(ID, score);</span><br><span class="line">        testees.push_back(testee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="built_in">string</span> term;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type &gt;&gt; term;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %s\n"</span>, i + <span class="number">1</span>, type, term.c_str());</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>) &#123;</span><br><span class="line">            queryOne(term);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>) &#123;</span><br><span class="line">            queryTwo(term);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queryThree(term);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>除了一开始的时候输出格式上有一些细节问题外，还有就是用map导致的超时，应该改为unordered_map。但是这些都很快解决了，最傻的是我犯了一个低级错误导致耽误了很长时间，就是第三个函数里的那个unordered_map我一开始是定义在函数外的，也就是全局范围，这会导致之后如果还有第二次查询第三类的话，就数据重叠了。所以说，还是题目做少了，才会犯这种低级错误，一定要多刷题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是第二道题25分类型，这个题文字有点多，一定要细心看清题目的要求。这类模拟题难就难在信息量多，容易忽略很多小细节，算法上没有难处。不过我在
      
    
    </summary>
    
      <category term="PAT" scheme="http://hoyyy.com/categories/PAT/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="String" scheme="http://hoyyy.com/tags/String/"/>
    
      <category term="Map" scheme="http://hoyyy.com/tags/Map/"/>
    
      <category term="Sort" scheme="http://hoyyy.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级 1152. Google Recruitment</title>
    <link href="http://hoyyy.com/2019/08/21/PAT%E7%94%B2%E7%BA%A7-1152-Google-Recruitment/"/>
    <id>http://hoyyy.com/2019/08/21/PAT甲级-1152-Google-Recruitment/</id>
    <published>2019-08-21T14:47:11.000Z</published>
    <updated>2019-08-21T14:56:44.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这道题是跟素数相关的，我发现PAT甲级第一题很喜欢考素数啊，出现过很多次了，不过都没办法难……</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant e. The person who could find this prime number could go to the next step in Google’s hiring process by visiting this website.</p><p>The natural constant e is a well known transcendental number（超越数）. The first several digits are: e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… where the 10 digits in bold are the answer to Google’s question.</p><p>Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number.</p><p>Input Specification:<br>Each input file contains one test case. Each case first gives in a line two positive integers: L (≤ 1,000) and K (\&lt; 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line.</p><p>Output Specification:<br>For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output 404 instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number.</p><p>Sample Input 1:<br>20 5<br>23654987725541023819</p><p>Sample Output 1:<br>49877</p><p>Sample Input 2:<br>10 3<br>2468024680</p><p>Sample Output 2:<br>404</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>给定一个L位的数字，找到一个K位的素数。<br>每K位为一个单位进行遍历，判断数字是否是素数，是则输出，不是则继续，最终没找到就输出404。需要注意的就是输入数字是个字符串大数，要局部转换成K位数字进行计算，然后使用经典素数判断算法即可。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> str_int = stoi(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">pow</span>(str_int, <span class="number">0.5</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str_int % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, K;</span><br><span class="line">    <span class="built_in">string</span> input;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; K &gt;&gt; input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(input.length() &lt; K) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"404"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= input.length() - K; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> sub = input.substr(i, K);</span><br><span class="line">            <span class="keyword">if</span>(isPrime(sub)) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; sub;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"404"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这道题是跟素数相关的，我发现PAT甲级第一题很喜欢考素数啊，出现过很多次了，不过都没办法难……&lt;/p&gt;
&lt;h2 id=&quot;题目原文&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="PAT" scheme="http://hoyyy.com/categories/PAT/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="Prime" scheme="http://hoyyy.com/tags/Prime/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学基础 线性表</title>
    <link href="http://hoyyy.com/2019/08/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://hoyyy.com/2019/08/19/计算机科学基础-线性表/</id>
    <published>2019-08-19T14:34:02.000Z</published>
    <updated>2019-08-21T15:01:49.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一章的主题是线性表，数据结构中最基础的部分。主要的内容是线性表本身的定义，线性表的一些基本操作，线性表的两种实现方法和其对比。文中代码不必拘泥细节，重点在于它所展现的核心步骤与思想。</p><h2 id="线性表的定义与基本操作"><a href="#线性表的定义与基本操作" class="headerlink" title="线性表的定义与基本操作"></a>线性表的定义与基本操作</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表是一种逻辑结构，是一种抽象的概念，而非具体的某个数据结构，他所表征的是数据元素之间的关系应该如何组织。</p><p>线性表的定义：具有相同特性数据元素的一个有限序列。<br>所包含元素个数为其表长，当表长为零的时候，该线性表为空表。</p><p>线性表核心的四大逻辑特性：</p><ol><li>存在唯一的一个表头元素；</li><li>存在唯一的一个队尾元素；</li><li>除表头元素外，线性表中每个数据元素有且仅有一个直接前驱；</li><li>除表尾元素外，线性表中每个数据元素有且仅有一个直接后继。</li></ol><h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><ol><li>初始化——构造一个空表；</li><li>求表长——获得线性表的表长；</li><li>按值查找——根据给定元素值查找线性表中是否含有该元素并返回位置；</li><li>按位查找——根据给定线性表的某个位置获得其元素值；</li><li>插入——将给定的位置和元素值添加到线性表中；</li><li>删除——将给定的线性表的某个位置删除该位置的元素值并返回该值；</li><li>遍历——按顺序访问所有的元素；</li><li>判空——判断线性表当前是否为空表；</li><li>销毁——回收线性表所占空间。</li></ol><h2 id="线性表的实现"><a href="#线性表的实现" class="headerlink" title="线性表的实现"></a>线性表的实现</h2><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><h4 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h4><p>用顺序存储结构实现的线性表叫做顺序表。</p><p>顺序存储结构是指，把线性表中的所有元素按照其逻辑顺序，依次存储从指定的存储位置开始的一块连续的物理存储空间中。其特点是逻辑顺序与物理顺序相同。</p><h4 id="顺序表的基本操作（三个）"><a href="#顺序表的基本操作（三个）" class="headerlink" title="顺序表的基本操作（三个）"></a>顺序表的基本操作（三个）</h4><p>顺序表的插入（五步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在顺序表L的第i个位置（1&lt;=i&lt;=L.length+1）插入新元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.判断要插入的位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.检查顺序表是否还有多余的物理空间可以插入</span></span><br><span class="line"><span class="keyword">if</span>(L.length &gt;= MaxSize) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.后面的元素往后移一个单位为新元素腾出空间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = L.length; j &gt;= i; j--) &#123;</span><br><span class="line">L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.插入元素</span></span><br><span class="line">L.data[i - <span class="number">1</span>] = e;</span><br><span class="line"><span class="comment">// 5.顺序表的长度加一</span></span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>顺序表的删除（四步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.判断要删除的位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.获得即将删除的元素</span></span><br><span class="line">e = L.data[i - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 3.将后面的元素往前移一个单位覆盖原来删除元素的位置又不改变顺序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.顺序表长度减一</span></span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>顺序表的按值查找（两步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line"><span class="comment">// 1.遍历查找，返回位序（即下标加一）</span></span><br><span class="line"><span class="keyword">if</span>(L.data[i] == e) &#123;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.如果没找到就返回位序0表示不存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三种操作的时间复杂度都是O(n)。</p><h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><p>用链式存储结构实现的线性表叫链表。</p><p>链式存储结构是指，不需要使用连续的物理存储空间，但是通过使用额外空间在每一个数据元素上都附加数据元素之间的逻辑关系，从而在离散的物理存储空间里实现线性表。</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>单链表是指除了包含数据域外，还包含一个指针域用来指向其直接后继结点的链表。</p><p>单链表还可以细分为带头结点的单链表和不带头结点的单链表。在带头结点的单链表中，头指针head指向头结点，头结点的数据域不带有任何信息，而头结点的指针域则指向单链表的第一个结点。之所以引入头结点的概念，是为了在操作上能统一，而不用刻意为了head指向的第一个元素单独做一个处理，同时head不会有指向NULL的情况。</p><p>在带头结点的单链表中，在head->next为NULL的时候，才表示这个单链表是空的。在不带头结点的单链表中，头指针head直接指向链表中的第一个结点，那么head为NULL的时候就表示链表是空的。</p><p>以下介绍单链表核心的六大操作。</p><p>单链表的头插法初始化（数据顺序与实际数据顺序相反但是简单）（四步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">LNode *s;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">// 1.分配头结点的空间并设置为空表</span></span><br><span class="line">L = (LNodeList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">9999</span>) &#123;</span><br><span class="line"><span class="comment">// 2.根据输入数据创建一个新结点</span></span><br><span class="line">s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line"><span class="comment">// 3.将新结点添加到已有链表的首元素结点位置</span></span><br><span class="line">s-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line"><span class="comment">// 4.继续创建下一个结点</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单链表的尾插法初始化（数据顺序与实际顺序相同但是需要额外操作）（七步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">// 1.分配头结点的空间</span></span><br><span class="line">L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="comment">// 2.创建两个指针分别指向新结点和尾结点</span></span><br><span class="line">LNode *s, *r = L;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">9999</span>) &#123;</span><br><span class="line"><span class="comment">// 3.根据输入数据创建一个新结点</span></span><br><span class="line">s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line"><span class="comment">// 4.把新结点添加到尾结点之后</span></span><br><span class="line">r-&gt;next = s;</span><br><span class="line"><span class="comment">// 5.添加完新结点后，新结点变成尾结点</span></span><br><span class="line">r = s;</span><br><span class="line"><span class="comment">// 6.继续创建下一个结点</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7.将尾结点的指针域设置为NULL</span></span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单链表的按位查找（线性表位序是从1开始的，返回位序的结点指针）（四步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 1.初始化遍历指针为首元素结点</span></span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="comment">// 2.如果位序不和法就返回NULL</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.如果p不为空且遍历索引小于要找的位序就继续循环遍历</span></span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;(j &lt; i)) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.返回给定位序结点的指针</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单链表的按值查找（三步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.初始化遍历指针为首元素结点</span></span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line"><span class="comment">// 2.遍历直到遍历指针为NULL或者为给定元素值的结点</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.返回遍历指针，没找到就是NULL</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单链表的插入（三步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获得前驱结点</span></span><br><span class="line">p = GetElem(L, i - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2.前驱结点的后继变成新结点的后继</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line"><span class="comment">// 3.前驱结点的后继设置为新结点</span></span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure></p><p>单链表的删除（四步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获得前驱结点</span></span><br><span class="line">p = GetElem(L, i - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2.获得要删除的当前结点</span></span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="comment">// 3.让前驱结点的指针域指向要删除的结点的后继</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="comment">// 4.释放删除结点空间</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></p><p>单链表的六个重要算法（头插法、尾插位、按位查找、按值查找、插入、删除）的时间复杂度都是O(n)。</p><p>但是当给定前驱结点进行插入的时候，就不需要其第一步，所以时间复杂度就是O(1)。另外删除也可以在给定要删除的结点的情况下实现O(1)的时间复杂度，即把后继的数据覆盖要删除的结点的数据，然后删除后继的结点。</p><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>双链表是指除了包含数据域外，还包含两个指针域分别用来指向其直接前驱结点和直接后继结点的链表。</p><p>带头结点的双链表为空的条件是head->next为NULL，不带头结点的双链表为空的条件为head为NULL。</p><p>以下重点介绍双链表的两大操作。</p><p>双链表的插入（四步）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.插入结点的后继设置为被插入的结点的后继</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line"><span class="comment">// 2.被插入的结点的后继的前驱设置为插入结点</span></span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line"><span class="comment">// 3.插入结点的前驱设置为被插入结点</span></span><br><span class="line">s-&gt;prior = p;</span><br><span class="line"><span class="comment">// 4.被插入结点的后继设置为插入结点</span></span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure></p><p>双链表的删除<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.要删除的结点的前驱的后继设置为要删除的结点的后继</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="comment">// 2.要删除的结点的后继的前驱设置为要删除的结点的前驱</span></span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="comment">// 3.释放删除结点的空间</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></p><p>在给定插入/删除位置结点的情况下上述操作时间复杂度都是O(1)。</p><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>循环单链表是指在单链表的基础上，把最后一个结点的指针域，由NULL变为指向第一个结点（带头结点的循环单链表的最后一个结点的指针域指向头结点，而不带头结点的循环单链表的最后一个结点的指针域则指向首元素结点，形式上都是指向head），那么这个链表就由一个单链表变为了一个循环单链表。</p><p>带头结点的循环单链表为空时，head等于head->next；不带头结点的循环单链表为空时，head为NULL。</p><h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>循环双链表是指在双链表的基础上，把最后一个结点的后继指针域指向第一个结点，同时把第一个结点的前驱指针域指向最后一个结点（这里提到的第一个结点的定义与循环单链表相同），那么这个链表就由一个双链表变味了一个循环双链表。</p><p>带头结点的循环双链表为空时，head->next等于head->prior等于head。不带头结点的循环双链表为空时，head为NULL。</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>静态链表是借助一维数组实现的，是用顺序存储空间实现离散存储结构的线性表。具体表现为一个结构体数组，每个结构体里包含一个数据域和一个指针域，指针域里存储的实际是结构体数组的下标，而非上述四种链表的物理地址。</p><p>对于结束的标志（替代NULL），静态链表的指针域可以设置为-1。</p><h3 id="线性表的顺序存储结构（顺序表）与链式存储结构（链表）的比较"><a href="#线性表的顺序存储结构（顺序表）与链式存储结构（链表）的比较" class="headerlink" title="线性表的顺序存储结构（顺序表）与链式存储结构（链表）的比较"></a>线性表的顺序存储结构（顺序表）与链式存储结构（链表）的比较</h3><h4 id="空间比较"><a href="#空间比较" class="headerlink" title="空间比较"></a>空间比较</h4><p>顺序表是在创建的时候就一次性把空间给分配好了，使用的是连续存储空间，所以能够存储的元素数量是有限的。</p><p>链表的存储空间是多次分配的，用多少分配多少，使用的是离散存储空间，理论上不存在上限。</p><h4 id="存储密度比较"><a href="#存储密度比较" class="headerlink" title="存储密度比较"></a>存储密度比较</h4><p>存储密度可以用数据域所占空间比结点实际使用总空间的比值来度量。</p><p>顺序表的每个结点只包含数据域本身，所以存储密度是1。</p><p>链表的每个结点除了数据域本身外，还包含指向其他结点的指针域，所以存储密度小于1。</p><h4 id="存取方式的比较"><a href="#存取方式的比较" class="headerlink" title="存取方式的比较"></a>存取方式的比较</h4><p>顺序表可以随机存取，也可以顺序存取。</p><p>链表只能顺序存取（访问某个元素前需要访问其之前所有的数据元素）。</p><h4 id="插入-删除效率比较"><a href="#插入-删除效率比较" class="headerlink" title="插入/删除效率比较"></a>插入/删除效率比较</h4><p>顺序表插入/删除算法的平均时间复杂度均为O(n)，平均需要移动一半的元素。</p><p>链表插入/删除算法的平均时间复杂度为O(1)，不需要移动元素，只需修改指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线性表两种实现方式：顺序表、链表。<br>其中链表可以根据有无头结点分为两类，但一般默认含有头结点。<br>链表根据指针域的特点可以分为：单链表、双链表、循环单链表、循环双链表。<br>同时结合顺序存储，可以实现静态链表。</p><p>线性表核心的三大操作分别是：查找、插入、删除。<br>其中顺序表要理解插入和删除需要移动元素的特点。<br>链表则需要知道头插尾插两种初始化方法、插入、删除、按值查找和按位查找。</p><p>理解两种存储方式的差异与各自的优缺点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这一章的主题是线性表，数据结构中最基础的部分。主要的内容是线性表本身的定义，线性表的一些基本操作，线性表的两种实现方法和其对比。文中代码不必
      
    
    </summary>
    
      <category term="Data Structure" scheme="http://hoyyy.com/categories/Data-Structure/"/>
    
    
      <category term="Linear list" scheme="http://hoyyy.com/tags/Linear-list/"/>
    
      <category term="Link list" scheme="http://hoyyy.com/tags/Link-list/"/>
    
      <category term="Array" scheme="http://hoyyy.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>C标准库 cctype/ctype.h</title>
    <link href="http://hoyyy.com/2019/08/14/C%E6%A0%87%E5%87%86%E5%BA%93-cctype-ctype-h/"/>
    <id>http://hoyyy.com/2019/08/14/C标准库-cctype-ctype-h/</id>
    <published>2019-08-13T16:02:36.000Z</published>
    <updated>2019-08-21T15:01:54.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近用C语言的一些标准库发现也蛮好用，用起来也很方便，性能上也很棒。由于之前一直使用Cpp的标准库，但是有时候怕有些场合不支持Cpp的一些新特性，导致反复修改数据结构浪费很多时间。同时发现有些考试规定了用C语言，最后决定还是系统了解一下C的标准库，以后在不牺牲太大方便程度下尽量用C语言写题目。</p><p>cctype库是用来分类和转换单独的字符的函数库，对于出现处理字符串的问题能起到相当大的作用。该库总共<em>12</em>个可用函数。所有函数都是is开头，说明都是判断类的函数。</p><h2 id="1-isalnum"><a href="#1-isalnum" class="headerlink" title="1. isalnum()"></a>1. isalnum()</h2><p>参数：int c<br>返回值：int</p><p>在C语言中，char的技术实现是整数，所以参数的类型是整数，这并不影响把一个char传入函数后的处理。</p><p>这个函数是用来判断参数字符是不是数字或者字母（大写和小写都算），如果是，就会返回非零值，如果不是，就返回零。如果这个函数是返回true（非零值），那么isalpha()或者isdigit()其中有一个也会返回true值。</p><h2 id="2-isalpha"><a href="#2-isalpha" class="headerlink" title="2. isalpha()"></a>2. isalpha()</h2><p>参数：int c<br>返回值：int</p><p>这个函数用于判断参数字符是不是一个ASCII中的字母，如果是的话，在isupper()或者islower()中必有一个是返回true值。</p><h2 id="3-isblank"><a href="#3-isblank" class="headerlink" title="3. isblank()"></a>3. isblank()</h2><p>参数：int c<br>返回值：int</p><p>特别要注意的是这是C99或Cpp11的标准中的函数。这个函数用来判断是否是空白字符（要区别于空字符)，有两个字符会返回true值，空格字符和Tab（\t)字符都可以。</p><h2 id="4-iscntrl"><a href="#4-iscntrl" class="headerlink" title="4. iscntrl()"></a>4. iscntrl()</h2><p>参数：int c<br>返回值：int</p><p>这个函数是用来判断参数字符是否是一个控制字符。控制字符是那种不会在屏幕上打印出来的字符，比如0x00到0x08的字符，Tab字符（\t)，0x0A到0x0D的字符（\f, \v, \n, \r），以及0x0E到0x1F的字符，最后是0x7F（DEL）字符。如果是上述控制字符，就会返回true值。</p><h2 id="5-isdigit"><a href="#5-isdigit" class="headerlink" title="5. isdigit()"></a>5. isdigit()</h2><p>参数：int c<br>返回值：int</p><p>这个函数用来判断参数字符是否是一个十进制数字，即从0到9的数字。如过是上述数字就返回true值。</p><h2 id="6-isgraph"><a href="#6-isgraph" class="headerlink" title="6. isgraph()"></a>6. isgraph()</h2><p>参数：int c<br>返回值：int</p><p>这个函数用来判断参数字符是否是会在屏幕上绘制可视化输出的字符，是除了控制字符（iscntrl()函数判断返回true值）和空格字符外的所有字符，后面会提到isprint()函数，两者唯一的不同是，如果参数是空格字符，isgraph()会返回非true值，而isprint()会返回true值。</p><h2 id="7-islower"><a href="#7-islower" class="headerlink" title="7. islower()"></a>7. islower()</h2><p>参数：int c<br>返回值：int</p><p>这个函数是用来判断参数字符是否是小写的字母，即从a到z（0x61到0x7A）。如果是上述字符，就返回true值。</p><h2 id="8-isupper"><a href="#8-isupper" class="headerlink" title="8. isupper()"></a>8. isupper()</h2><p>参数：int c<br>返回值：int</p><p>这个函数是用来判断参数字符是否是大写的字母，即从A到Z（0x41到0x5A）。如果是上述字符，就返回true值。</p><h2 id="9-isprint"><a href="#9-isprint" class="headerlink" title="9. isprint()"></a>9. isprint()</h2><p>参数：int c<br>返回值：int</p><p>这个函数是用来判断参数字符是否是可打印的字符，是完全相反于iscntrl()函数的（虽然有点多余，但在可读性上面还是更好）。像之前所提到的，与isgraph()函数唯一不同的就是空格字符的对待，这个函数会返回true值（因为一个空格在屏幕上也会打印出来），而isgraph()函数不会返回true值。</p><h2 id="10-ispunct"><a href="#10-ispunct" class="headerlink" title="10. ispunct()"></a>10. ispunct()</h2><p>参数：int c<br>返回值：int</p><p>这个函数用来判断参数字符是否是一个标点（punctuation）字符，而这个里面的字符范围是，在isgraph()函数的范围内，但是排除在isalnum()函数之外的所有字符，即所有可视字符中除了字母和数字的所有字符。</p><h2 id="11-isspace"><a href="#11-isspace" class="headerlink" title="11. isspace()"></a>11. isspace()</h2><p>参数：int c<br>返回值：int</p><p>这个函数用来判断参数字符是否是white-space字符，它包含了isblank()判断的空格字符和Tab字符，同时还有另外四个控制字符（\n, \v, \f, \r）。如果是上述六个字符，就返回true值。</p><h2 id="12-isxdigit"><a href="#12-isxdigit" class="headerlink" title="12. isxdigit()"></a>12. isxdigit()</h2><p>参数：int c<br>返回值：int</p><p>这个函数是用来判别是否是十六进制的表示字符，包括0到9，a到e，A到E。如果是上述字符就返回true值。</p><h2 id="返回真值的范围图"><a href="#返回真值的范围图" class="headerlink" title="返回真值的范围图"></a>返回真值的范围图</h2><p>引用自<a href="http://www.cplusplus.com/reference/cctype/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/cctype/</a><br>（x表示返回真值的对应字符）<br><img src="img.png" alt></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>严格来讲每个函数都可以用直接的不等式判断来实现，但是使用这些函数可以增加代码的可读性，已经减少出错的可能性，建议以后单独处理字符的时候使用这个函数库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近用C语言的一些标准库发现也蛮好用，用起来也很方便，性能上也很棒。由于之前一直使用Cpp的标准库，但是有时候怕有些场合不支持Cpp的一些新
      
    
    </summary>
    
      <category term="C&amp;C++ Language" scheme="http://hoyyy.com/categories/C-C-Language/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="String" scheme="http://hoyyy.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级 1059. Prime Factors</title>
    <link href="http://hoyyy.com/2019/08/11/PAT%E7%94%B2%E7%BA%A7-1059-Prime-Factors/"/>
    <id>http://hoyyy.com/2019/08/11/PAT甲级-1059-Prime-Factors/</id>
    <published>2019-08-11T13:45:43.000Z</published>
    <updated>2019-08-21T15:01:59.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这道题目是25分题，第二道第三道难度，需要有特定的数学知识作为背景。</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>Given any positive integer N, you are supposed to find all of its prime factors, and write them in the format N = p​1^k1*p2^k2​*⋯*pm^km.</p><p>Input Specification:<br>Each input file contains one test case which gives a positive integer N in the range of long int.</p><p>Output Specification:<br>Factor N in the format N = p​1^k1*p2^k2*…*pm^km, where pi’s are prime factors of N in increasing order, and the exponent k​i is the number of pi – hence when there is only one p​i, ki is 1 and must NOT be printed out.</p><p>Sample Input:<br>97532468</p><p>Sample Output:<br>97532468=2^2*11*17*101*1291</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题的前提是要知道质因数分解定律，而啥也不知道的我虽然一开始完全不知道，但是很快我就意识到这个题目要有结果则必须要有一个条件——所有的给定数一定能由有限个素数相乘得到，所以纯靠暴力算法是行不通的，于是放弃题目上网找资料。</p><p>果然，确实存在上述定理。</p><p>那么题目就是纯粹的已有算法的重现了，麻烦一点的可能是不能按网上的找到一个因子就输出，而是要先记录下来再按规定的格式输出。我这里用的map记录。</p><p>具体的算法是，i从2开始（如果N小于等于2就直接输出），用i除N，如果能整除，就说明i是一个素数因子，然后N /= i循环上述步骤，直到不能整除，就i++，继续。那么如果纯粹+1的操作不会导致出现非素数的因子吗？不会。由于从2开始，如果N里面还有2的倍数，那么肯定能再第一步里整除，无法进入到后面的+1步骤去，所以进入+1了说明之前能整除的i的倍数不会成为N的因子了，比如4，在i加到4之前，就已经分解为2*2了。之后的也类似。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld="</span>, N);</span><br><span class="line">    <span class="keyword">if</span>(N &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%ld"</span>, N);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; factors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(N % i == <span class="number">0</span>) &#123;</span><br><span class="line">                factors[i]++;</span><br><span class="line">                N /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = factors.begin(); iter != factors.end(); iter++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(iter == factors.begin()) &#123;</span><br><span class="line">                <span class="keyword">if</span>((*iter).second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; (*iter).first &lt;&lt; <span class="string">"^"</span> &lt;&lt; (*iter).second;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; (*iter).first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>((*iter).second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; (*iter).first &lt;&lt; <span class="string">"^"</span> &lt;&lt; (*iter).second;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; (*iter).first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题不会做是真的没办法，完全是相关知识不知道，这里说明，第一，要广泛学习，尤其是算法以及其各种数学理论，尤其是数论相关；第二，像这题如果发现不给定某个规定，比如这里的质因数分解定理，就无法做下去的话，或者变得超乎寻常的复杂时，那就默认这个规定成立从而去做。当然这题如果冷静分析其实也可以通过设计算法得到同样的算法，只是知道背后的数学背景会更快更从容地设计算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这道题目是25分题，第二道第三道难度，需要有特定的数学知识作为背景。&lt;/p&gt;
&lt;h2 id=&quot;题目原文&quot;&gt;&lt;a href=&quot;#题目原文&quot; c
      
    
    </summary>
    
      <category term="PAT" scheme="http://hoyyy.com/categories/PAT/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="Prime" scheme="http://hoyyy.com/tags/Prime/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级 1058. A+B in Hogwarts</title>
    <link href="http://hoyyy.com/2019/08/11/PAT%E7%94%B2%E7%BA%A7-1058-A-B-in-Hogwarts/"/>
    <id>http://hoyyy.com/2019/08/11/PAT甲级-1058-A-B-in-Hogwarts/</id>
    <published>2019-08-11T12:23:00.000Z</published>
    <updated>2019-08-11T12:31:57.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这道题是典型的自定义进制计算，20分值题，属于第一道题难度，不应该超过20分钟。</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>If you are a fan of Harry Potter, you would know the world of magic has its own currency system – as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute A+B where A and B are given in the standard form of Galleon.Sickle.Knut (Galleon is an integer in [0,10^7], Sickle is an integer in [0, 17), and Knut is an integer in [0, 29)).</p><p>Input Specification:<br>Each input file contains one test case which occupies a line with A and B in the standard form, separated by one space.</p><p>Output Specification:<br>For each test case you should output the sum of A and B in one line, with the same format as the input.</p><p>Sample Input:<br>3.2.1 10.16.27</p><p>Sample Output:<br>14.1.28</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>有三个位，每个位的进制不同，最低位是29进制，中间位是17进制，最高位则范围在[0, 10^7]。这里还好我之前熟悉了一下sacnf()的使用，不然按以前的脑回路，因为输入中夹杂有小数点，我会用getchar()来处理输入然后转数值类型，要是真这样估计要浪费很多时间。而这里就只需要按照scanf()的输入规则，在每个说明符间写一个小数点即可按照题目要求读入。</p><p>然后计算过程是，从低位开始加，有进位就记录，最后得到最终结果。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> AG, AS, AK, BG, BS, BK;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d.%d.%d %d.%d.%d"</span>, &amp;AG, &amp;AS, &amp;AK, &amp;BG, &amp;BS, &amp;BK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">    <span class="keyword">int</span> G, S, K;</span><br><span class="line">    <span class="keyword">int</span> rS = <span class="number">0</span>, rK = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(AK + BK &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        K = AK + BK - <span class="number">29</span>;</span><br><span class="line">        rK++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        K = AK + BK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(AS + BS + rK &gt;= <span class="number">17</span>) &#123;</span><br><span class="line">        S = AS + BS + rK - <span class="number">17</span>;</span><br><span class="line">        rS++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        S = AS + BS + rK;</span><br><span class="line">    &#125;</span><br><span class="line">    G = AG + BG + rS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d.%d.%d"</span>, G, S, K);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这道题大概用了11分钟，庆幸于之前复习了scanf()的使用，其他的可讲之处不多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这道题是典型的自定义进制计算，20分值题，属于第一道题难度，不应该超过20分钟。&lt;/p&gt;
&lt;h2 id=&quot;题目原文&quot;&gt;&lt;a href=&quot;#题
      
    
    </summary>
    
      <category term="PAT" scheme="http://hoyyy.com/categories/PAT/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="Decimal" scheme="http://hoyyy.com/tags/Decimal/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级 1054. The Dominant Color</title>
    <link href="http://hoyyy.com/2019/08/10/PAT%E7%94%B2%E7%BA%A7-1054.-The-Dominant-Color/"/>
    <id>http://hoyyy.com/2019/08/10/PAT甲级-1054.-The-Dominant-Color/</id>
    <published>2019-08-10T12:06:32.000Z</published>
    <updated>2019-08-21T15:02:12.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A strictly dominant color takes more than half of the total area. Now given an image of resolution M by N (for example, 800×600), you are supposed to point out the strictly dominant color.</p><p>Input Specification:<br>Each input file contains one test case. For each case, the first line contains 2 positive numbers: M (≤800) and N (≤600) which are the resolutions of the image. Then N lines follow, each contains M digital colors in the range [0,2^24). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space.</p><p>Output Specification:<br>For each test case, simply print the dominant color in a line.</p><p>Sample Input:<br>5 3<br>0 0 255 16777215 24<br>24 24 0 0 24<br>24 0 24 24 24</p><p>Sample Output:<br>24</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这个题目是20分量级的，属于最简单的第一道题，应该要在20分钟内做完。</p><p>大概意思就是给一个矩阵，代表一副图片像素点阵，其中如果某个像素值占了所有像素值的一半以上，则称为dominant color，找出给出点阵中的dominant color，而题中标明了所有给的case中一定会有结果存在，所以只需要记录每个像素出现的次数，最后输出出现次数最多的像素值即可。</p><p>这题关键在于确定合适的数据结构。如果用一个2^24大小的数组就会极其浪费空间，并且如果要排序获得出现次数最多的像素值效率也极其低下。用map是比较好的选择，不需要开拓包含所有可能像素的空间，只需要每次对对应颜色key的value加一操作即可。最后通过用转换为vector来进行排序，输出排第一的颜色值。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++字符串和数值转换也包含在里面</span></span><br><span class="line"><span class="comment">// #include &lt;string&gt;</span></span><br><span class="line"><span class="comment">// C++向量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// map和multimap都在里面</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">// set和multiset都在里面</span></span><br><span class="line"><span class="comment">// #include &lt;set&gt;</span></span><br><span class="line"><span class="comment">// 各类算法包括排序、查询、最大最小、等等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于数学使用</span></span><br><span class="line"><span class="comment">// #include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">// 关于字符串和数值类型的转换、随机数、动态内存分配、C的排序等等</span></span><br><span class="line"><span class="comment">// #include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">// 关于C字符串的操作</span></span><br><span class="line"><span class="comment">// #include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">// 关于数值的最大最小边界的定义</span></span><br><span class="line"><span class="comment">// #include &lt;climits&gt;</span></span><br><span class="line"><span class="comment">// 字符操作</span></span><br><span class="line"><span class="comment">// #include &lt;cctype&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;M, &amp;N);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">    <span class="keyword">int</span> pixel;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pixel);</span><br><span class="line">            record[pixel]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; recordVec(record.begin(), record.end());</span><br><span class="line">    sort(recordVec.begin(), recordVec.end(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*recordVec.begin()).first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来我想，其实没必要全部都遍历完所有的输入，因为只要某个颜色的出现次数到达了一半，就可以确定这就是结果了，后面的输入就没有必要了，也不用进行排序。但是带来的开销是需要对每一次输入都进行一次判定当前次数，所以我进行了一下性能对比。</p><p>以下是算法代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++字符串和数值转换也包含在里面</span></span><br><span class="line"><span class="comment">// #include &lt;string&gt;</span></span><br><span class="line"><span class="comment">// C++向量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// map和multimap都在里面</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">// set和multiset都在里面</span></span><br><span class="line"><span class="comment">// #include &lt;set&gt;</span></span><br><span class="line"><span class="comment">// 各类算法包括排序、查询、最大最小、等等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于数学使用</span></span><br><span class="line"><span class="comment">// #include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">// 关于字符串和数值类型的转换、随机数、动态内存分配、C的排序等等</span></span><br><span class="line"><span class="comment">// #include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">// 关于C字符串的操作</span></span><br><span class="line"><span class="comment">// #include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">// 关于数值的最大最小边界的定义</span></span><br><span class="line"><span class="comment">// #include &lt;climits&gt;</span></span><br><span class="line"><span class="comment">// 字符操作</span></span><br><span class="line"><span class="comment">// #include &lt;cctype&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;M, &amp;N);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">    <span class="keyword">int</span> pixel;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pixel);</span><br><span class="line">            record[pixel]++;</span><br><span class="line">            <span class="keyword">if</span>(record[pixel] &gt; M * N / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; pixel;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于之前的输入完后排序，5个case的时间分别是（clang++）：3ms, 3ms, 39ms, 13ms, 3ms。空间分别是：512kB, 428kB, 384kB, 864kB, 384kB。</p><p>而每次输入都判定当前次数的算法5个case的时间分别是（clang++）：4ms, 3ms, 89ms, 12ms, 3ms。空间是：524kB, 516kB, 356kB, 864kB, 492kB。</p><p>经过多次提交测试，其实两种算法的差别基本不大。当然也可能与数据规模有关，受限于测试数据，没办法深入测试了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目原文&quot;&gt;&lt;a href=&quot;#题目原文&quot; class=&quot;headerlink&quot; title=&quot;题目原文&quot;&gt;&lt;/a&gt;题目原文&lt;/h2&gt;&lt;p&gt;Behind the scenes in the computer’s memory, color is always ta
      
    
    </summary>
    
      <category term="PAT" scheme="http://hoyyy.com/categories/PAT/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="Map" scheme="http://hoyyy.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>C++ string的使用</title>
    <link href="http://hoyyy.com/2019/08/04/C-string%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://hoyyy.com/2019/08/04/C-string的使用/</id>
    <published>2019-08-04T14:12:07.000Z</published>
    <updated>2019-08-21T15:02:16.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在PAT中的一二题中经常出现字符处理的题目，如果对string熟悉的话，其实难度就不大了，这里再复习一遍。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">string</span> str1, str2;</span><br></pre></td></tr></table></figure><h2 id="【STAR】倒序遍历"><a href="#【STAR】倒序遍历" class="headerlink" title="【STAR】倒序遍历"></a>【STAR】倒序遍历</h2><p>使用倒序迭代器函数rbegin()和rend()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> riter = str.rbegin(); riter != str.rend(); riter++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *riter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="【STAR】获得字符长度"><a href="#【STAR】获得字符长度" class="headerlink" title="【STAR】获得字符长度"></a>【STAR】获得字符长度</h2><p>使用size()成员方法或者length()成员函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; str.size();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.length();</span><br></pre></td></tr></table></figure></p><p>之所以有两个是历史原因，两个都返回字节数（bytes）。</p><h2 id="改变string的容量"><a href="#改变string的容量" class="headerlink" title="改变string的容量"></a>改变string的容量</h2><p>使用resize()成员方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.resize(n);</span><br><span class="line">str.resize(n, <span class="string">'+'</span>);</span><br><span class="line"><span class="comment">// n是目标大小</span></span><br><span class="line"><span class="comment">// 如果string本身的长度小于n，则会从第一个开始到第n个（带到长度n）被保留下来，剩余的则会被切除</span></span><br><span class="line"><span class="comment">// 如果stirng本身的长度大于n，则会在原来string的基础上在后面添加空的位置直到达到长度n，如果指定了字符，则多的位置全部初始化为该字符</span></span><br></pre></td></tr></table></figure></p><h2 id="将string变成空字符串"><a href="#将string变成空字符串" class="headerlink" title="将string变成空字符串"></a>将string变成空字符串</h2><p>使用clear()成员方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.clear();</span><br></pre></td></tr></table></figure></p><h2 id="【STAR】判断string是不是空字符串"><a href="#【STAR】判断string是不是空字符串" class="headerlink" title="【STAR】判断string是不是空字符串"></a>【STAR】判断string是不是空字符串</h2><p>使用empty()成员方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isEmpty = str.empty();</span><br></pre></td></tr></table></figure></p><h2 id="访问特定位置的字符，并可以修改"><a href="#访问特定位置的字符，并可以修改" class="headerlink" title="访问特定位置的字符，并可以修改"></a>访问特定位置的字符，并可以修改</h2><p>使用[]或者at()方法，都接受从0到length() - 1的size_t类型索引参数，结果是引用类型。如果string是const修饰，则是常量引用，则不可以修改。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; str[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.at(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h2 id="访问开头和结尾的字符，并可以修改"><a href="#访问开头和结尾的字符，并可以修改" class="headerlink" title="访问开头和结尾的字符，并可以修改"></a>访问开头和结尾的字符，并可以修改</h2><p>使用front()和back()成员方法分别获得string的首个字符的引用和最后一个字符的引用，但是不能对空字符串使用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; str.front();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.back();</span><br></pre></td></tr></table></figure></p><h2 id="【STAR】字符串尾部拼接"><a href="#【STAR】字符串尾部拼接" class="headerlink" title="【STAR】字符串尾部拼接"></a>【STAR】字符串尾部拼接</h2><p>使用+=运算符（3个重载运算）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str += <span class="string">"K"</span>;    <span class="comment">//C风格的显式字符串</span></span><br><span class="line">str += str1;    <span class="comment">//string拼接到string</span></span><br><span class="line">str += <span class="string">'\n'</span>;    <span class="comment">//直接拼接字符</span></span><br></pre></td></tr></table></figure></p><p>使用append()成员方法（6个重载方法）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str.append(str2);    <span class="comment">//string拼接string</span></span><br><span class="line">str.append(str2, <span class="number">6</span>, <span class="number">3</span>);    <span class="comment">//拼接另一个string的子串，C++里的范围一般是第一个参数指定开始位置，而第二个参数指定长度</span></span><br><span class="line">str.append(<span class="string">"Nice to see you"</span>, <span class="number">5</span>);    <span class="comment">//拼接C风格字符串同时指定前多少个</span></span><br><span class="line">str.append(<span class="string">"Nice to see you"</span>);    <span class="comment">//或者全部拼接一个C字符串</span></span><br><span class="line">str.append(<span class="number">10u</span>, <span class="string">'0'</span>);    <span class="comment">//指定拼接某个数量的字符</span></span><br><span class="line">str.append(str2.begin() + <span class="number">8</span>, str2.end());    <span class="comment">//指定拼接串的迭代器范围</span></span><br><span class="line"></span><br><span class="line">str.append&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">0x2D</span>);    <span class="comment">//本质上和指定数目拼接字符相同</span></span><br></pre></td></tr></table></figure></p><p>使用push_back()成员方法将字符拼接到string末尾<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.push_back(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="给字符串赋值（覆盖原值）"><a href="#给字符串赋值（覆盖原值）" class="headerlink" title="给字符串赋值（覆盖原值）"></a>给字符串赋值（覆盖原值）</h2><p>使用=运算符或者assign()成员方法（6个重载方法）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str.assign(str1);    <span class="comment">//完整赋值</span></span><br><span class="line">str.assign(str1, <span class="number">10</span>, <span class="number">6</span>);   <span class="comment">//指定开始位置和长度部分赋值</span></span><br><span class="line">str.assign(<span class="string">"Are you kidding?"</span>, <span class="number">6</span>);   <span class="comment">//C字符串以及指定从头开始的长度</span></span><br><span class="line">str.assign(<span class="string">"Maybe"</span>);    <span class="comment">//C字符串的完整赋值</span></span><br><span class="line">str.assign(<span class="number">10</span>, <span class="string">'*'</span>);    <span class="comment">//指定数目的字符赋值</span></span><br><span class="line">str.assign(str1.begin(), str1.end() - <span class="number">1</span>);    <span class="comment">//指定范围迭代器赋值</span></span><br><span class="line"></span><br><span class="line">str.assign&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">0x2D</span>);    <span class="comment">//本质上和指定数目拼接字符相同</span></span><br></pre></td></tr></table></figure></p><p>这套重载和拼接是一样的</p><h2 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h2><p>使用insert()成员方法</p><h2 id="擦除部分字符串（会减少长度）"><a href="#擦除部分字符串（会减少长度）" class="headerlink" title="擦除部分字符串（会减少长度）"></a>擦除部分字符串（会减少长度）</h2><p>使用erase()成员方法</p><h2 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h2><p>使用replace()成员方法（实际上就是erase()和insert()的结合效果）</p><h2 id="交换两个string的内容"><a href="#交换两个string的内容" class="headerlink" title="交换两个string的内容"></a>交换两个string的内容</h2><p>使用swap()成员方法</p><h2 id="删除最后一个字符"><a href="#删除最后一个字符" class="headerlink" title="删除最后一个字符"></a>删除最后一个字符</h2><p>使用pop_back()成员方法</p><h2 id="转换成C字符串"><a href="#转换成C字符串" class="headerlink" title="转换成C字符串"></a>转换成C字符串</h2><p>使用c_str()成员方法，返回一个字符串指针</p><h2 id="【STAR】查找string的子列"><a href="#【STAR】查找string的子列" class="headerlink" title="【STAR】查找string的子列"></a>【STAR】查找string的子列</h2><p>使用find()成员函数（4个重载）<br>返回子串中第一个字符第一次出现的位置，类型是size_t<br>如果没有找到就返回string\::npos<br>rfind()成员函数则是返回最后一个匹配的子串的第一个字符的位置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> found = str.find(str1);</span><br><span class="line"><span class="keyword">size_t</span> found = str.find(<span class="string">"What a good day"</span>, <span class="number">2</span>, <span class="number">6</span>);    <span class="comment">//指定范围</span></span><br><span class="line"><span class="keyword">size_t</span> found = str.find(<span class="string">"Hi"</span>);</span><br><span class="line"><span class="keyword">size_t</span> found = str.find(<span class="string">'h'</span>);    <span class="comment">//字符</span></span><br></pre></td></tr></table></figure></p><h2 id="【STAR】获得string的子列"><a href="#【STAR】获得string的子列" class="headerlink" title="【STAR】获得string的子列"></a>【STAR】获得string的子列</h2><p>使用substr()成员方法<br>提供开始位置的参数，子串长度的参数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> subs1 = str.substr(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">string</span> subs2 = str.substr(<span class="number">2</span>);    <span class="comment">//从2到结尾</span></span><br></pre></td></tr></table></figure></p><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p>使用compare()成员变量<br>提供6个重载<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.compare(str1) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//They are equal</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(str.compare(<span class="number">6</span>, <span class="number">5</span>, str1) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//str位置6开始长度为5的子串和str1相比</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(str.compare(str.size() - <span class="number">5</span>, <span class="number">5</span>, str1) &#123;</span><br><span class="line"><span class="comment">//str最后五个字符与str1相比</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以抽象理解为str - str1</span></span><br></pre></td></tr></table></figure></p><p>如果返回结果等于零，则两个字符串相等<br>返回结果小于零，则说明参数里要匹配的字符串第一个不匹配的字符值要更大，或者全部匹配了，但是这个字符串比调用这个方法的字符串要长。<br>返回结果大于零，说明参数里要匹配的字符串第一个不匹配的字符值要更小，或者全部匹配了，但是这个字符串要更短。</p><h2 id="字符流读入"><a href="#字符流读入" class="headerlink" title="字符流读入"></a>字符流读入</h2><p>使用string\::getline()类方法<br>第一个参数是一个流，第二个参数是保存的string，如果指定了第三个参数一个字符，就在出现这个字符的时候停止输入，没有就直到遇到换行符。(第三个参数或者换行符会被读取但是被丢弃）</p><h2 id="【STAR】字符串转int"><a href="#【STAR】字符串转int" class="headerlink" title="【STAR】字符串转int"></a>【STAR】字符串转int</h2><p>使用stoi()类方法<br>第一个参数是要转换的string；第二个参数是一个指针，这指针是指向一个size_t类型的变量，也可以指定为nullptr不用，用了就会将那个值设置为要转换的string的数字部分的之后第一个位置；第三个参数是指定进制，默认是10，如果指定为0，则会根据stirng的格式判断该转化为什么进制。</p><h2 id="各类string转其他数值类型"><a href="#各类string转其他数值类型" class="headerlink" title="各类string转其他数值类型"></a>各类string转其他数值类型</h2><p>转单浮点stof()，双浮点stod()</p><h2 id="【STAR】数值类型转string"><a href="#【STAR】数值类型转string" class="headerlink" title="【STAR】数值类型转string"></a>【STAR】数值类型转string</h2><p>使用to_string()类方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于方法参数，C++里面的哲学是一致的，主要有：</p><ol><li>指定一定数目重复的值，则有两个参数，前者是_数量<em>，后者是</em>具体值_。</li><li>关于<em>C字符串</em>如果指定长度，则是从<em>开头位置</em>开始到那个_长度_为止。</li><li>对于通过位置数值截取容器对象，则第一个参数一般是<em>开始位置</em>，第二个参数是<em>截取长度</em>。</li><li>迭代器则是<em>开始迭代器</em>和<em>尾后迭代器</em>确定范围。<br>几个一定要记住并熟练掌握的成员方法：</li><li>倒序迭代器rbegin()和rend()</li><li>获取字符串长度length()或者size()</li><li>使用+=或者append()拼接字符串</li><li>使用find()查找子列是否存在</li><li>使用substr()获得子列<br>然后是一些类方法：</li><li>使用stoi()类方法将string变为int</li><li>使用to_string()类方法将数值类型转为string</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在PAT中的一二题中经常出现字符处理的题目，如果对string熟悉的话，其实难度就不大了，这里再复习一遍。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;
      
    
    </summary>
    
      <category term="C&amp;C++ Language" scheme="http://hoyyy.com/categories/C-C-Language/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="String" scheme="http://hoyyy.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>C语言输入输出函数以及字符串处理</title>
    <link href="http://hoyyy.com/2019/08/04/C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://hoyyy.com/2019/08/04/C语言输入输出函数以及字符串处理/</id>
    <published>2019-08-04T13:40:11.000Z</published>
    <updated>2019-08-21T15:02:21.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇是我之前做题的过程中整理的一些关于C语言的输入输出函数的使用细节，以及一些C字符串的处理函数使用。熟悉这些知识可以在写编程题的过程中提高代码的运行效率，实现一些特定的题目要求格式。在不需要使用C++类作为输入输出对象的情况下，使用stdio要比iostream的速度要快很多，所以尽量应使用stdio的输入输出函数。同时对于字符处理，在不是用string的情况下字符数组也有很多方便的处理函数。</p><h2 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf()函数"></a>printf()函数</h2><h3 id="printf-常用的转换说明符"><a href="#printf-常用的转换说明符" class="headerlink" title="printf()常用的转换说明符"></a>printf()常用的转换说明符</h3><p>在做1052的过程中我就发现了printf()用在处理格式化的输出上会使其变得极其简单，而不需要自己还去写一个格式输出的函数。</p><ol><li>%d ：有符号十进制整数</li><li>%c ：一个字符</li><li>%e / %E ：浮点数的e / E科学计数法</li><li>%f ：浮点数的十进制计数法</li><li>%s ：字符串</li><li>%% ： 打印百分号</li><li>%o ：无符号八进制整数</li><li>%x / %X ：无符号十六进制用0f / 0F的（大小写）整数</li><li>%u ：无符号十进制整数</li><li>%g / %G ：根据数值选择%f或者%f或%e / %f或者%E。科学计数法在指数小于-4或者大于等于精度时使用</li></ol><h3 id="printf-常用的转换说明符的修饰符"><a href="#printf-常用的转换说明符的修饰符" class="headerlink" title="printf()常用的转换说明符的修饰符"></a>printf()常用的转换说明符的修饰符</h3><ol><li>整数 ：表示字段的最小宽度，如果不能容纳就会使用更宽的字段</li><li>小数点 + 整数 ：表示小数点保留的位数</li><li>l ：和整数转换说明符（%d）一起使用，表示long int或者unsigned long int</li><li>ll ： 和整数转换说明符（%d）一起使用，表示long long int或者unsigned long long int</li><li>L ：和浮点数转换说明符（%f）一起使用，表示一个long double</li><li>t ：和整数转换说明符（%d）一起使用，表示ptrdiff_t（指针距离）的值</li><li>z ： 和整数转化说明符（%d）一起使用，表示size_t（sizeof的返回类型）的值</li><li>- ：左对齐（因为输出默认是右对齐的）</li><li>+ ：有符号的值如果为正数就会显示加号，负数就会显示负号（默认显示）</li><li>空格 ：有符号的值如果为正数就会前面空一格，负数就会显示负号（默认显示）</li><li># ：若修饰%o则输出以0开头；若修饰%x或者%X，则以0x或者0X开头；对于所有浮点数，即使没有任何数字也会打印一个小数点，对于%g和%G则防止尾随的灵被删除</li><li>0 ：对于所有的数字格式用前导零而不是空格填充字段，如果出现了负号或者指定了精度（对于整数）则忽略该标志</li></ol><h2 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h2><h3 id="scanf-常用的转换说明符"><a href="#scanf-常用的转换说明符" class="headerlink" title="scanf()常用的转换说明符"></a>scanf()常用的转换说明符</h3><p>基本和printf()一致，多一个%p表示输入的是一个指针</p><h3 id="scanf-常用的转换说明符的修饰符"><a href="#scanf-常用的转换说明符的修饰符" class="headerlink" title="scanf()常用的转换说明符的修饰符"></a>scanf()常用的转换说明符的修饰符</h3><ol><li>整数 ：在遇到第一个空白字符或者达到这个给定的最大宽度的时候结束输入</li></ol><h3 id="scanf-使用的一些注意"><a href="#scanf-使用的一些注意" class="headerlink" title="scanf()使用的一些注意"></a>scanf()使用的一些注意</h3><ol><li>在两个转换说明符中间添加字符：意味着希望读取那两个类型的输入时，中间应该还输入添加的字符，用于格式读入</li><li>除了%c之外的说明符都会自动跳过输入项之前的所有空格，所以对于第一条，两个转换符之间加不加空格都会跳过输入中间的空格。而对于%c，如果前面加一个空格表示读入遇到的第一个非空白字符，而没加的话就会把包括空白字符在内的所有字符都当作读入对象</li><li>scanf()的返回值是所有读入项目的个数</li></ol><h2 id="关于-修饰符在printf-和scanf-中的作用"><a href="#关于-修饰符在printf-和scanf-中的作用" class="headerlink" title="关于 * 修饰符在printf()和scanf()中的作用"></a>关于 * 修饰符在printf()和scanf()中的作用</h2><ol><li>在printf()中，* 修饰转换说明符后，则应该在后面的对应变量之前再加一个变量来动态指定限定的最小字段宽度。</li><li>在scanf()中，* 修饰转换说明符后，表明这个位置的输入跳过，进入之后的输入项，用来读入数据时，忽略某些不需要的数据</li></ol><p>作者：Anyer Hoy<br>博客：<a href="https://hoyyy.me" target="_blank" rel="noopener">https://hoyyy.me</a></p><h2 id="C字符串处理函数"><a href="#C字符串处理函数" class="headerlink" title="C字符串处理函数"></a>C字符串处理函数</h2><p>使用前应引用cstring</p><h3 id="strlen-函数和sizeof运算符"><a href="#strlen-函数和sizeof运算符" class="headerlink" title="strlen()函数和sizeof运算符"></a>strlen()函数和sizeof运算符</h3><p>sizeof是以字节为单位给出数据的大小，而strlen()则是以字符为单位给出字符串的长度</p><h3 id="getchar-函数和putchar-函数"><a href="#getchar-函数和putchar-函数" class="headerlink" title="getchar()函数和putchar()函数"></a>getchar()函数和putchar()函数</h3><p>这两个是定义在<cstdio>的，单独读入和输出每个字符，对于c = getchar()赋值语句本身也可以表示读取的字符本身，可以用于输入判断，如<br><code>if(c = getchar()) != &#39;a&#39;){}</code></cstdio></p><h3 id="gets-函数（get-string）"><a href="#gets-函数（get-string）" class="headerlink" title="gets()函数（get string）"></a>gets()函数（get string）</h3><p>遇到换行符才会停止，不会包括换行符，并且会在末尾添上一个空字符，但是它不会检查预留存储区是否能够容纳实际输入的数据，所以很不安全。<br>与scanf()不同的是gets()趋向于获取字符串，一整行，而前者趋向于获取单词</p><h3 id="puts-函数-（put-string）"><a href="#puts-函数-（put-string）" class="headerlink" title="puts()函数 （put string）"></a>puts()函数 （put string）</h3><p>puts()接受一个字符串参数的地址，然后输出，不同于printf()，它会自动换行</p><h3 id="strcat-函数与strncat-函数-（string-concatenation）"><a href="#strcat-函数与strncat-函数-（string-concatenation）" class="headerlink" title="strcat()函数与strncat()函数 （string concatenation）"></a>strcat()函数与strncat()函数 （string concatenation）</h3><p>strcat()函数会将第二个参数提供的字符串拼接到第一个参数提供的字符串后面<br>但是如果第一个参数字符串提供的空间不足以容纳第二个字符串，多出来的字符会溢出到相邻的存储单元。<br>而strncat()函数多了第三个参数用来限定最多允许添加到第一个参数字符串尾部的字符的数目（空字符也算作一个字符）<br>函数返回的是字符指针类型，指向第一个参数的字符串（被拼接的）</p><h3 id="strcmp-函数与strncmp-函数-（string-comparison"><a href="#strcmp-函数与strncmp-函数-（string-comparison" class="headerlink" title="strcmp()函数与strncmp()函数 （string comparison)"></a>strcmp()函数与strncmp()函数 （string comparison)</h3><p>如果两个字符串相同则会返回0，而如果前者比后者的字符值小则返回-1，而大则返回1，可以理解为减法，而比较规则是基于ASCII表的，而大写字母是开始于0x41（A）的，小写字母开始于0x61（a）的，所以大写字母比小写字母都会要小。</p><h3 id="strcpy-函数和strncpy-函数-string-copy"><a href="#strcpy-函数和strncpy-函数-string-copy" class="headerlink" title="strcpy()函数和strncpy()函数 (string copy)"></a>strcpy()函数和strncpy()函数 (string copy)</h3><p>由于C中的字符串是无法赋值的，所以这个函数使用来复制第二个参数的字符串给第一个参数，同时函数返回值是第一个参数的字符指针。同时第一个参数不需要指向字符串的开始，可以从后面某个位置开始复制。而安全版也是在第三个参数限制复制过来的字符串的最大长度（空字符也是算的）</p><h3 id="sprintf-函数"><a href="#sprintf-函数" class="headerlink" title="sprintf()函数"></a>sprintf()函数</h3><p>把几个元素组合成一个字符串的一种途径，第一个参数是输出的目标字符串，而后面则是和printf()函数一样的项目列表。</p><h3 id="strstr-函数"><a href="#strstr-函数" class="headerlink" title="strstr()函数"></a>strstr()函数</h3><p>返回在第一个参数的字符串中第一次出现第二个参数所指的字符串的位置的指针。也就是查找某个子串第一次出现的位置</p><h2 id="cctype头文件"><a href="#cctype头文件" class="headerlink" title="cctype头文件"></a>cctype头文件</h2><p>主要用来判断字符是否是某些数值类型，比如isdigit()函数判断是否是一个十进制整数，如果是则返回非零数，不是则返回0。再比如isupper()判断是否是大写，而isspace()判断是否是空格等等<br>toupper()则返回某个字母的大写<br>tolower()则返回某个字母的小写<br>而没有对应大小写时则返回值不发生任何变化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇是我之前做题的过程中整理的一些关于C语言的输入输出函数的使用细节，以及一些C字符串的处理函数使用。熟悉这些知识可以在写编程题的过程中提高
      
    
    </summary>
    
      <category term="C&amp;C++ Language" scheme="http://hoyyy.com/categories/C-C-Language/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="String" scheme="http://hoyyy.com/tags/String/"/>
    
      <category term="I/O" scheme="http://hoyyy.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级 1053. Path of Equal Weight</title>
    <link href="http://hoyyy.com/2019/08/04/PAT%E7%94%B2%E7%BA%A7-1053-Path-of-Equal-Weight/"/>
    <id>http://hoyyy.com/2019/08/04/PAT甲级-1053-Path-of-Equal-Weight/</id>
    <published>2019-08-04T09:44:55.000Z</published>
    <updated>2019-08-10T15:37:14.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从上次三月份的PAT失利以来，到现在一直在断断续续为九月份的PAT备战，但是离考试还有一个月，我却还有一百多道题还没刷完，每周自己记录的笔记也没有坚持下来。<br>为了在接下来的一个月里进一步提升自己解决问题的能力，之后我将把我每次解答PAT甲级的代码以及相应的反思整合成博客，包括之前已经完成的在内，发布在我的个人博客上，希望通过这种方式强迫自己多写代码，随时保持编程的手感。</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>Given a non-empty tree with root R, and with weight Wi assigned to each tree node T​i. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.</p><p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.<br><img src="figure1.png" alt></p><p>Input Specification:<br>Each input file contains one test case. Each case starts with a line containing 0 &lt; N ≤ 100, the number of nodes in a tree, M (&lt;N), the number of non-leaf nodes, and 0 &lt; S &lt; 2^​30, the given weight number. The next line contains N positive numbers where W​i (&lt;1000) corresponds to the tree node Ti. Then M lines follow, each in the format:<br>ID K ID1 ID2 … IDK<br>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 00.</p><p>Output Specification:<br>For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p><p>Note: sequence {A​1, A​2, ⋯, An} is said to be greater than sequence {B1, B2, ⋯, Bm} if there exists 1 ≤ k &lt; min{n, m} such that A​i = Bi for i=1,⋯,k, and Ak+1 &gt; B​k+1.</p><p>Sample Input:<br>20 9 24<br>10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2<br>00 4 01 02 03 04<br>02 1 05<br>04 2 06 07<br>03 3 11 12 13<br>06 1 09<br>07 2 08 10<br>16 1 15<br>13 3 14 16 17<br>17 2 18 19</p><p>Sample Output:<br>10 5 2 7<br>10 4 10<br>10 3 3 6 2<br>10 3 3 6 2</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>算法上，计算树中路径的长度，自然就想到了深度优先搜索（DFS）。题目的要求是，从根结点出发，到达某个叶结点的总权重和要等于给定的某个值，然后按顺序输出这条路径上的权重，那么就在深度搜索的过程中记录到达当前时的权重和以及路径，然后和给定值比较，第一：如果权重和小于给定值，就递归继续向下一层遍历，并传递到目前为止的权重和给下一层；第二：如果权重和等于给定值，再判断当前结点是否是叶结点，如果是就说明是符合题目要求的路径，根据记录的路径输出，如果不是，就结束向下遍历；第三，如果大于给定值，说明这条路径上没有符合要求的结果，停止遍历。</p><p>数据结构上，我开始是用二维矩阵存储布尔值来模拟一棵树，如果第一维编号是第二维编号的父亲结点，就设置为true，如果不是就是false（初始化的时候用fill函数默认初始化为false）。另外用一个一维整型数组单独存储每个编号结点的权重。</p><p>但是后来我发现题目有一个要求要实现起来就有点麻烦了。题目要求，一旦符合给定值的路径不唯一，就按照先出现的结点权重大的那一条路径优先来输出，而不能按随机找到的顺序输出。</p><p>这里我想了一个办法，用vector数组来存储树，这样在输入每个结点的子结点的时候对他们按照权重进行排序，那么深度优先遍历的过程中就会优先遍历那些权重更大的结点，这样自然输出的顺序就符合题目要求。</p><p>最后我按照设想写好了代码，并运行。</p><p>However……</p><p>case2始终没办法通过，网上查资料也没有人提到这个case为什么会在另外5个case全部正确的情况下给出 <strong>答案错误</strong>（也就是说既不是格式也不是内存，是算法上确实存在漏洞）</p><p>这里我觉得可以复习一下如何通过几个常见的case反馈结果来分析错误的类型。<br><strong>答案正确</strong> 就是其字面意思。<br><strong>编译错误</strong> 则一般是语法上出现错误，有时候也需要注意特性的兼容性。<br><strong>格式错误</strong> 则一般是题目规定了输出格式，比如必须用空格隔开，结尾不允许有空格等。<br><strong>运行超时</strong> 则是代码效率太低了，首先考虑自己的代码是否在算法层面效率低，比如有nlogn的解法但是自己为了简单用的n^2的解法，这种只能重新设计程序。如果算法自己想不出更好时间复杂度的解决方案，就尝试在数据结构和输入输出流上优化，比如是否可以用C的数组替代C++的容器或者不用自己构建类也能写出来，而存在大量输入输出的情况下，应该优先考虑用C的cstdio函数库的中函数。<br><strong>答案错误</strong> 则一般是算法设计上存在问题，导致不能得到正确的结果。这个也要看情况，如果是全部case都是答案错误，那么就应该思考自己到底是来干嘛的；如果是一部分答案正确，一部分答案错误，那很有可能是题目给的数据有一些特殊的情况，比如和零有关的情况或者最大边界情况，像这个题目我最后有一个case答案错误就是因为没有考虑到如果只给出一个根结点而没有子结点的情况。<br><strong>内存超限</strong> 出现比较少，除非题目明确限制了能使用的空间从而让你不能用常规的方法做，或者自己用了很复杂的面向对象结构。<br><strong>段错误</strong> 则一般指内存越界的情况或者访问了没有定义的内存区域，这种时候要仔细检查一些访问数组的下标是否有超出的情况，尤其是在循环里。</p><p>以上是我做题的过程中常见的错误，其他的应该是从没见过。</p><p>回到本题，前面说了是因为没有考虑到只给出一个根结点的情况，因为我的输出是在DFS函数内输出的，而遍历从根结点的子结点开始遍历，而因为其没有子结点，一进去马上又出来了啥也没干，所以这个case就没法通过，而应该在这个跟结点权重等于给定值的情况下输出这个权重。</p><p>作者：Yaron Ho<br>博客：<a href="https://hoyyy.me" target="_blank" rel="noopener">https://hoyyy.me</a></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++字符串和数值转换也包含在里面</span></span><br><span class="line"><span class="comment">// #include &lt;string&gt;</span></span><br><span class="line"><span class="comment">// C++向量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// map和multimap都在里面</span></span><br><span class="line"><span class="comment">// #include &lt;map&gt;</span></span><br><span class="line"><span class="comment">// set和multiset都在里面</span></span><br><span class="line"><span class="comment">// #include &lt;set&gt;</span></span><br><span class="line"><span class="comment">// 各类算法包括排序、查询、最大最小、等等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于数学使用</span></span><br><span class="line"><span class="comment">// #include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">// 关于字符串和数值类型的转换、随机数、动态内存分配、C的排序等等</span></span><br><span class="line"><span class="comment">// #include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">// 关于C字符串的操作</span></span><br><span class="line"><span class="comment">// #include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">// 关于数值的最大最小边界的定义</span></span><br><span class="line"><span class="comment">// #include &lt;climits&gt;</span></span><br><span class="line"><span class="comment">// 字符操作</span></span><br><span class="line"><span class="comment">// #include &lt;cctype&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结构</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[<span class="number">101</span>];</span><br><span class="line"><span class="comment">// 每个结点的权重</span></span><br><span class="line"><span class="keyword">int</span> weights[<span class="number">101</span>];</span><br><span class="line"><span class="comment">// 总共结点数目，非叶结点数，给定数值</span></span><br><span class="line"><span class="keyword">int</span> N, M, S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先遍历加输出部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathW)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[root].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum + weights[tree[root][i]] &lt; S) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newPathW = pathW;</span><br><span class="line">            newPathW.push_back(weights[tree[root][i]]);</span><br><span class="line">            dfs(tree[root][i], sum + weights[tree[root][i]], newPathW);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum + weights[tree[root][i]] == S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[tree[root][i]].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pathW.size(); i++) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; pathW[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, weights[tree[root][i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给每个非叶结点的子结点们排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareNode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weights[a] &gt; weights[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;N, &amp;M, &amp;S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;weights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当只有一个跟结点的时候</span></span><br><span class="line">    <span class="keyword">if</span>(M == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(weights[<span class="number">0</span>] == S) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, weights[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nonLeaf, leafNum, leaf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;nonLeaf, &amp;leafNum);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; children;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; leafNum; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;leaf);</span><br><span class="line">            children.push_back(leaf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序子结点</span></span><br><span class="line">        sort(children.begin(), children.end(), compareNode);</span><br><span class="line">        tree[nonLeaf] = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathW;</span><br><span class="line">    pathW.push_back(weights[<span class="number">0</span>]);</span><br><span class="line">    dfs(<span class="number">0</span>, weights[<span class="number">0</span>], pathW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于我写代码的格式，对于PAT，我已经有了一个固定的模版，每次写能省下不少（也不是很多）的时间，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++字符串和数值转换也包含在里面</span></span><br><span class="line"><span class="comment">// #include &lt;string&gt;</span></span><br><span class="line"><span class="comment">// C++向量</span></span><br><span class="line"><span class="comment">// #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// map和multimap都在里面</span></span><br><span class="line"><span class="comment">// #include &lt;map&gt;</span></span><br><span class="line"><span class="comment">// set和multiset都在里面</span></span><br><span class="line"><span class="comment">// #include &lt;set&gt;</span></span><br><span class="line"><span class="comment">// 各类算法包括排序、查询、最大最小、等等</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于数学使用</span></span><br><span class="line"><span class="comment">// #include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">// 关于字符串和数值类型的转换、随机数、动态内存分配、C的排序等等</span></span><br><span class="line"><span class="comment">// #include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">// 关于C字符串的操作</span></span><br><span class="line"><span class="comment">// #include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">// 关于数值的最大最小边界的定义</span></span><br><span class="line"><span class="comment">// #include &lt;climits&gt;</span></span><br><span class="line"><span class="comment">// 字符操作</span></span><br><span class="line"><span class="comment">// #include &lt;cctype&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于上述代码里我对只有一个根结点的处理很不优雅，但是在正式考试的时候还是先解决问题优先，以后工作了也是，能安全稳定地完成目标是要放在第一位的，而在有余力的同时再去考虑结构优化，因为每个人的能力都是有限的，不可能一开始就考虑得全面和尽善尽美，只能一步一步去完善自己。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个题目是30分级的，也就是甲级考试4道题的最后一题，我没有计时，但大概写代码一个半小时到两个小时左右，严重超时，应该限制在50分钟左右最好。因为数据结构选择的摇摆耽误了不少时间，后来因为一个case没办法通过又耽误了一个上午，所以总的来说是不尽人意的，后面还需要对每个题目严格计时，从而提高效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自从上次三月份的PAT失利以来，到现在一直在断断续续为九月份的PAT备战，但是离考试还有一个月，我却还有一百多道题还没刷完，每周自己记录的笔
      
    
    </summary>
    
      <category term="PAT" scheme="http://hoyyy.com/categories/PAT/"/>
    
    
      <category term="C&amp;C++" scheme="http://hoyyy.com/tags/C-C/"/>
    
      <category term="Tree" scheme="http://hoyyy.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://hoyyy.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>三种智能优化算法解决十个无约束单目标优化问题</title>
    <link href="http://hoyyy.com/2019/04/08/%E4%B8%89%E7%A7%8D%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%8D%81%E4%B8%AA%E6%97%A0%E7%BA%A6%E6%9D%9F%E5%8D%95%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <id>http://hoyyy.com/2019/04/08/三种智能优化算法解决十个无约束单目标优化问题/</id>
    <published>2019-04-08T03:01:46.000Z</published>
    <updated>2019-08-19T14:51:49.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文主要讲述的是解决十个无约束单目标优化问题的过程和结果，即求这些函数在给定区间内的最小值。<br>首先说明了用遗传算法解决的思路和结果，但是其中有两个函数无法得到理想结果，于是使用粒子群算法重新计算，但是无法解决的问题反而变成了四个，于是又用差分演化算法尝试解决，结果发现遗传算法无法解决的问题差分演化也没办法解决，但是另外八个问题的结果精度上比遗传算法高了很多。最后经过反复尝试各种修改参数和代码调试，在把迭代次数从5000上调到50000之后，发现无法解决的两个函数才表现出一定的稳定收敛。</p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>无约束单目标优化、连续优化、最小化、遗传算法、粒子群算法、差分演化算法</p><h2 id="一-目标问题概述"><a href="#一-目标问题概述" class="headerlink" title="一  目标问题概述"></a>一  目标问题概述</h2><blockquote><p>Wenyin Gong. 2019. Test functions for single-objective optimization. 1, 1, Article 1 (January 2019), 2 pages.</p></blockquote><h3 id="1-Rastrigin-Function"><a href="#1-Rastrigin-Function" class="headerlink" title="1. Rastrigin Function"></a>1. Rastrigin Function</h3><p><img src="Rastrigin-Math.png" alt></p><h3 id="2-Ackley-Function"><a href="#2-Ackley-Function" class="headerlink" title="2. Ackley Function"></a>2. Ackley Function</h3><p><img src="Ackley-Math.png" alt></p><h3 id="3-Sphere-Function"><a href="#3-Sphere-Function" class="headerlink" title="3. Sphere Function"></a>3. Sphere Function</h3><p><img src="Sphere-Math.png" alt></p><h3 id="4-Rosenbrock-Function"><a href="#4-Rosenbrock-Function" class="headerlink" title="4. Rosenbrock Function"></a>4. Rosenbrock Function</h3><p><img src="Rosenbrock-Math.png" alt></p><h3 id="5-Beale-Function"><a href="#5-Beale-Function" class="headerlink" title="5. Beale Function"></a>5. Beale Function</h3><p><img src="Beale-Math.png" alt></p><h3 id="6-Schaffer-Function"><a href="#6-Schaffer-Function" class="headerlink" title="6. Schaffer Function"></a>6. Schaffer Function</h3><p><img src="Schaffer-Math.png" alt></p><h3 id="7-Styblinski-Tang-Function"><a href="#7-Styblinski-Tang-Function" class="headerlink" title="7. Styblinski-Tang Function"></a>7. Styblinski-Tang Function</h3><p><img src="Styblinski-Math.png" alt></p><h3 id="8-Bukin-Function"><a href="#8-Bukin-Function" class="headerlink" title="8. Bukin Function"></a>8. Bukin Function</h3><p><img src="Bukin-Math.png" alt></p><h3 id="9-Himmelblaus-Function"><a href="#9-Himmelblaus-Function" class="headerlink" title="9. Himmelblaus Function"></a>9. Himmelblaus Function</h3><p><img src="Himmelblau&#39;s-Math.png" alt></p><h3 id="10-Cross-in-tray-Function"><a href="#10-Cross-in-tray-Function" class="headerlink" title="10. Cross in tray Function"></a>10. Cross in tray Function</h3><p><img src="Crossintray-Math.png" alt></p><h2 id="程序设计思路"><a href="#程序设计思路" class="headerlink" title="程序设计思路"></a>程序设计思路</h2><p>程序实现的思路主要是以下几个部分：</p><ol><li>输入部分（决定解决的问题）</li><li>确定变量维度以及每个维度的上下界（根据选择的问题）</li><li>初始化参数</li><li>算法迭代</li><li>输出结果</li></ol><p>为提高可读性，本文的程序运行结果数据以及代码统一放在文末，并会有对比分析。如果有兴趣可以前往参考。</p><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><p>用遗传算法（Genetic Algorithm）解决，程序算法迭代部分如下：</p><ol><li>选择。采用君主方案选择，即将结果排序后，选出最好的那一个个体，然后奇数位个体全部替换成这个最好的，偶数位个体全部与最好的个体进行交叉。</li><li>变异。随机变异。</li><li>新的种群和上一代种群合并，并排序，留下前一半的个体作为新的种群进行迭代。</li><li>记录排序后种群的第一个个体的函数值</li></ol><p>迭代运行5000次，使用遗传算法能够确认八个函数的迭代结果会比较稳定，误差也在可接受范围内，但是Rosenbrock函数和Bukin函数无法稳定到可以推测出的最小值，考虑到可能是这种算法不适合解决这两个问题，所以我们尝试其他的优化算法。</p><h2 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a>粒子群算法</h2><p>由于Rosenbrock函数和Bukin函数使用遗传算法没法收敛，我们把初始化参数和算法迭代换成粒子群算法，其迭代的步骤如下：</p><ol><li>遍历每个个体</li><li>对每个个体，如果其目标函数值要比历史最佳要好，更新这个个体历史最佳函数值，以及将这个个体的参数更新</li><li>再对每个个体，根据其个体历史最佳函数值，决定是否更新全局最佳函数值以及更改全局最佳个体参数</li><li>更新速度和位置</li><li>边界处理</li><li>记录这一代最佳函数值</li></ol><p>然后对十个函数进行了重新测试，迭代次数为5000次，测试结果有点出人意料，Rosenbrock函数多次出现了直接等于0.0的结果（即直接出了最小值，而不是接近），但是不稳定，多次测试还是会出现其他结果。Bukin函数则还是不收敛。而之前没有问题的Rastrigin函数和Styblinski-Tang函数却也无法收敛了。于是我们再尝试差分演化算法。</p><h2 id="差分演化算法"><a href="#差分演化算法" class="headerlink" title="差分演化算法"></a>差分演化算法</h2><p>我们将初始化参数和算法迭代改成差分演化算法，其迭代步骤如下：</p><ol><li>变异算子随着迭代进行深入，每次都相应改变</li><li>随机变异</li><li>随机交叉</li><li>边界处理</li><li>选择</li><li>记录最好的函数值</li></ol><p>差分演化算法迭代次5000次，遗传算法中没办法得到结果的Rosenbrock Function和Bukin Function还是没办法得到结果，其他的问题能很好的解决，并且和粒子群算法一样，精度极高，这个在文末数据分析里会对比讨论。</p><h2 id="最终解决"><a href="#最终解决" class="headerlink" title="最终解决"></a>最终解决</h2><p>到了这个时候，我大概能猜到一点问题的所在了，通过差分算法，即使这两个函数的结果还是有部分波动，但是它们确实在一个贴近结果（0.0）的附近波动，所以方法应该是没错了，但是精度还是有问题。</p><p>而我之前由于在个人电脑上运行，考虑到出结果的时间，同时也通过观察迭代过程图发现很早就能收敛到较低的范围，而越往后提升基本不大了，没想过用一个特别大的迭代数，因为要等的时间确实太久了。</p><p>在我把迭代次数从5000次改成50000次之后，精度提高了一个数量级，这说明了对于优化算法迭代次数将很大程度决定最终的效果。但是通过分析数据，Rosenbrock函数和Bukin函数相对于其他函数，更难获得最小值，这和函数本身的性质以及算法都有关系，由于篇幅原因就不进行深入了。</p><p>最后，很感谢《智能优化技术》这门课的老师，龚文引教授对我的启发以及帮助，学习完这门课收获很多！同时由于我本人水平有限，文中难免出现疏漏之处，还望谅解！</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>关于遗传算法、粒子群算法、差分演化算法在迭代次数为5000次时解决十个问题分别得到的结果对比：<br><img src="data.jpg" alt><br>对比可以发现，</p><ol><li>遗传算法和差分演化算法在解决Rosenbrock函数和Bukin函数的时候效果都不佳，但是差分演化算法还是表现的要比遗传算法要好。</li><li>粒子群算法无法解决Rastrigin函数和Bukin函数。但是在解决Rosenbrock函数、Styblinski-Tang函数以及Himmelblau’s函数时出现了一个奇怪的现象，它会有时候收敛到最小值（另外两个算法很难解决的Rosenbrock函数在这里直接给出了精确值），但是有时候会收敛到另一个固定的值附近。</li><li>在正常解决的函数里，粒子群算法和差分演化算法要比遗传算法精确很多很多，粒子群算法和差分演化算法在解决的函数里表现的精度很接近。</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>首先是模块funclib.py，这个模块用来实现十个优化问题，同时用只一个函数调用，提供输出菜单中显示的序号就行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funclib.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rastrigin_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    A = <span class="number">10.0</span></span><br><span class="line">    sum = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> xi <span class="keyword">in</span> X:</span><br><span class="line">        sum += (xi ** <span class="number">2</span> - A * cos(<span class="number">2</span> * pi * xi))</span><br><span class="line">    <span class="keyword">return</span> sum + A * len(X)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ackley_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-20</span> * exp(<span class="number">-0.2</span> * ((<span class="number">0.5</span> * (X[<span class="number">0</span>] ** <span class="number">2</span> + X[<span class="number">1</span>] ** <span class="number">2</span>)) ** <span class="number">0.5</span>)) - exp(<span class="number">0.5</span> * (cos(<span class="number">2</span> * pi * X[<span class="number">0</span>]) + cos(<span class="number">2</span> * pi * X[<span class="number">1</span>]))) + e + <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sphere_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum([xi ** <span class="number">2</span> <span class="keyword">for</span> xi <span class="keyword">in</span> X])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rosenbrock_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    sum = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(X) - <span class="number">1</span>):</span><br><span class="line">        sum += (<span class="number">100</span> * (X[i + <span class="number">1</span>] - X[i] ** <span class="number">2</span>) ** <span class="number">2</span> + (<span class="number">1</span> - X[i]) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beale_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.5</span> - X[<span class="number">0</span>] + X[<span class="number">0</span>] * X[<span class="number">1</span>]) ** <span class="number">2</span> + (<span class="number">2.25</span> - X[<span class="number">0</span>] + X[<span class="number">0</span>] * (X[<span class="number">1</span>] ** <span class="number">2</span>)) ** <span class="number">2</span> + (<span class="number">2.625</span> - X[<span class="number">0</span>] + X[<span class="number">0</span>] * (X[<span class="number">1</span>] ** <span class="number">3</span>)) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schaffer_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> + (cos(sin(abs(X[<span class="number">0</span>] ** <span class="number">2</span> - X[<span class="number">1</span>] ** <span class="number">2</span>))) ** <span class="number">2</span> - <span class="number">0.5</span>) / (<span class="number">1</span> + <span class="number">0.001</span> * (X[<span class="number">0</span>] ** <span class="number">2</span> + X[<span class="number">1</span>] ** <span class="number">2</span>)) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">styblinski_tang_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum([(xi ** <span class="number">4</span> - <span class="number">16</span> * (xi ** <span class="number">2</span>) + <span class="number">5</span> * xi) / <span class="number">2</span> <span class="keyword">for</span> xi <span class="keyword">in</span> X])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bukin_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * (abs(X[<span class="number">1</span>] - <span class="number">0.01</span> * (X[<span class="number">0</span>] ** <span class="number">2</span>)) ** <span class="number">0.5</span>) + <span class="number">0.01</span> * abs(X[<span class="number">0</span>] + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">himmelblaus_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (X[<span class="number">0</span>] ** <span class="number">2</span> + X[<span class="number">1</span>] - <span class="number">11</span>) ** <span class="number">2</span> + (X[<span class="number">0</span>] + X[<span class="number">1</span>] ** <span class="number">2</span> - <span class="number">7</span>) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corssintray_func</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-0.0001</span> * ((abs(sin(X[<span class="number">0</span>]) * sin(X[<span class="number">1</span>]) * exp(abs(<span class="number">100</span> - (X[<span class="number">0</span>] ** <span class="number">2</span> + X[<span class="number">1</span>] ** <span class="number">2</span>) ** <span class="number">0.5</span> / pi))) + <span class="number">1</span>) ** <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj_func</span><span class="params">(func_i, X)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func_i == <span class="string">'0'</span>:</span><br><span class="line">        <span class="keyword">return</span> rastrigin_func(X)</span><br><span class="line">    <span class="keyword">elif</span> func_i == <span class="string">'1'</span>:</span><br><span class="line">        <span class="keyword">return</span> ackley_func(X)</span><br><span class="line">    <span class="keyword">elif</span> func_i == <span class="string">'2'</span>:</span><br><span class="line">        <span class="keyword">return</span> sphere_func(X)</span><br><span class="line">    <span class="keyword">elif</span> func_i == <span class="string">'3'</span>:</span><br><span class="line">        <span class="keyword">return</span> rosenbrock_func(X)</span><br><span class="line">    <span class="keyword">elif</span> func_i == <span class="string">'4'</span>:</span><br><span class="line">        <span class="keyword">return</span> beale_func(X)</span><br><span class="line">    <span class="keyword">elif</span> func_i == <span class="string">'5'</span>:</span><br><span class="line">        <span class="keyword">return</span> schaffer_func(X)</span><br><span class="line">    <span class="keyword">elif</span> func_i == <span class="string">'6'</span>:</span><br><span class="line">        <span class="keyword">return</span> styblinski_tang_func(X)</span><br><span class="line">    <span class="keyword">elif</span> func_i == <span class="string">'7'</span>:</span><br><span class="line">        <span class="keyword">return</span> bukin_func(X)</span><br><span class="line">    <span class="keyword">elif</span> func_i == <span class="string">'8'</span>:</span><br><span class="line">        <span class="keyword">return</span> himmelblaus_func(X)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> corssintray_func(X)</span><br></pre></td></tr></table></figure></p><p>每个算法文件中需要导入的其他模版。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 通过obj_func来调用函数，提供对应函数序号和自变量数组作为参数</span></span><br><span class="line"><span class="keyword">from</span> funclib <span class="keyword">import</span> obj_func</span><br><span class="line"><span class="comment"># 绘图库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></p><p>程序的输入部分，由用户选择要测试哪个函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意从0开始</span></span><br><span class="line">message = <span class="string">"Choose the index of function to calculate:\n \</span></span><br><span class="line"><span class="string">0. Rastrigin function\n \</span></span><br><span class="line"><span class="string">1. Ackley function\n \</span></span><br><span class="line"><span class="string">2. Sphere function\n \</span></span><br><span class="line"><span class="string">3. Rosenbrock function\n \</span></span><br><span class="line"><span class="string">4. Beale function\n \</span></span><br><span class="line"><span class="string">5. Schaffer function\n \</span></span><br><span class="line"><span class="string">6. Styblinski_tang function\n \</span></span><br><span class="line"><span class="string">7. Bukin function\n \</span></span><br><span class="line"><span class="string">8. Himmelblaus function\n \</span></span><br><span class="line"><span class="string">9. Cross_in_tray function\n"</span></span><br><span class="line"></span><br><span class="line">func_to_cal = input(message)</span><br><span class="line"><span class="keyword">while</span> func_to_cal &gt; <span class="string">'9'</span> <span class="keyword">and</span> func_to_cal &lt; <span class="string">'0'</span>:</span><br><span class="line">    func_to_cal = input(message)</span><br></pre></td></tr></table></figure></p><p>根据前面的用户选的函数，设定自变量的维度和上下限。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解的维度</span></span><br><span class="line">pop_dim = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> func_to_cal <span class="keyword">in</span> <span class="string">"0236"</span>:</span><br><span class="line">    pop_dim = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解空间的上下界</span></span><br><span class="line"><span class="comment">#如果是2维则有x，y之分</span></span><br><span class="line"><span class="comment">#x_top, x_bottom, y_top, y_bottom</span></span><br><span class="line"><span class="comment">#如果是n维则只有一个上下界</span></span><br><span class="line"><span class="comment">#xi_top, xi_bottom</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> func_to_cal <span class="keyword">in</span> <span class="string">"0236"</span>:</span><br><span class="line">    <span class="keyword">if</span> func_to_cal == <span class="string">'0'</span>:</span><br><span class="line">        xi_top = <span class="number">5.12</span></span><br><span class="line">        xi_bottom = <span class="number">-5.12</span></span><br><span class="line">    <span class="keyword">elif</span> func_to_cal == <span class="string">'2'</span>:</span><br><span class="line">        xi_top = <span class="number">100</span></span><br><span class="line">        xi_bottom = <span class="number">-100</span></span><br><span class="line">    <span class="keyword">elif</span> func_to_cal == <span class="string">'3'</span>:</span><br><span class="line">        xi_top = <span class="number">30</span></span><br><span class="line">        xi_bottom = <span class="number">-30</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        xi_top = <span class="number">5</span></span><br><span class="line">        xi_bottom = <span class="number">-5</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> func_to_cal == <span class="string">'1'</span>:</span><br><span class="line">        x_top = y_top = <span class="number">5</span></span><br><span class="line">        x_bottom = y_bottom = <span class="number">-5</span></span><br><span class="line">    <span class="keyword">elif</span> func_to_cal == <span class="string">'4'</span>:</span><br><span class="line">        x_top = y_top = <span class="number">4.5</span></span><br><span class="line">        x_bottom = y_bottom = <span class="number">-4.5</span></span><br><span class="line">    <span class="keyword">elif</span> func_to_cal == <span class="string">'5'</span>:</span><br><span class="line">        x_top = y_top = <span class="number">100</span></span><br><span class="line">        x_bottom = y_bottom = <span class="number">-100</span></span><br><span class="line">    <span class="keyword">elif</span> func_to_cal == <span class="string">'7'</span>:</span><br><span class="line">        x_top = <span class="number">-5</span></span><br><span class="line">        x_bottom = <span class="number">-15</span></span><br><span class="line">        y_top = <span class="number">3</span></span><br><span class="line">        y_bottom = <span class="number">-3</span></span><br><span class="line">    <span class="keyword">elif</span> func_to_cal == <span class="string">'8'</span>:</span><br><span class="line">        x_top = y_top = <span class="number">5</span></span><br><span class="line">        x_bottom = y_bottom = <span class="number">-5</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x_top = y_top = <span class="number">10</span></span><br><span class="line">        x_bottom = y_bottom = <span class="number">-10</span></span><br></pre></td></tr></table></figure></p><p>遗传算法的参数初始化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 种群规模</span></span><br><span class="line">pop_num = <span class="number">100</span></span><br><span class="line"><span class="comment"># 随机初始化种群</span></span><br><span class="line">pop = np.random.rand(pop_num, pop_dim)</span><br><span class="line"><span class="comment"># 选择、交叉、变异后的新种群</span></span><br><span class="line">new_pop = np.random.rand(pop_num, pop_dim)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定维度</span></span><br><span class="line"><span class="keyword">if</span> pop_dim == <span class="number">2</span> :</span><br><span class="line">    pop[:,<span class="number">0</span>] *= (x_top - x_bottom)</span><br><span class="line">    pop[:,<span class="number">0</span>] += np.repeat(np.array([x_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line">    pop[:,<span class="number">1</span>] *= (y_top - y_bottom)</span><br><span class="line">    pop[:,<span class="number">1</span>] += np.repeat(np.array([y_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_dim):</span><br><span class="line">        pop[:,i] *= (xi_top - xi_bottom)</span><br><span class="line">        pop[:,i] += np.repeat(np.array([xi_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉概率</span></span><br><span class="line">porb_cro = <span class="number">0.8</span></span><br><span class="line"><span class="comment"># 变异概率</span></span><br><span class="line">prob_mut = <span class="number">0.1</span></span><br><span class="line"><span class="comment"># 迭代次数</span></span><br><span class="line">iterations = <span class="number">5000</span></span><br><span class="line"><span class="comment"># 历代最优</span></span><br><span class="line">trace = np.zeros(iterations, dtype=float)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算初代的结果</span></span><br><span class="line">results = np.zeros(pop_num, dtype=float)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">    results[i] = obj_func(func_to_cal, pop[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于是求最小值，所以升序排列结果，并记录原来的索引位置</span></span><br><span class="line">sorted_indices = np.argsort(results)</span><br><span class="line">results.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据目标函数值对种群进行排序，按照函数值升序排列</span></span><br><span class="line">sorted_pop = np.zeros((pop_num, pop_dim), dtype=float)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">    sorted_pop[i] = pop[sorted_indices[i]].copy()</span><br><span class="line"></span><br><span class="line">pop = sorted_pop.copy()</span><br></pre></td></tr></table></figure></p><p>遗传算法的迭代过程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开始迭代遗传</span></span><br><span class="line"><span class="keyword">for</span> iter <span class="keyword">in</span> range(<span class="number">0</span>, iterations):</span><br><span class="line">    <span class="comment">#君主方案进行选择</span></span><br><span class="line">    emper = pop[<span class="number">0</span>].copy()</span><br><span class="line">    <span class="comment">#每次交叉点的个数</span></span><br><span class="line">    noPoint = round(pop_dim * porb_cro)</span><br><span class="line">    <span class="comment">#交叉基因的位置</span></span><br><span class="line">    poPoint = np.random.randint(<span class="number">0</span>, pop_dim, size=(int(pop_num / <span class="number">2</span>), noPoint))</span><br><span class="line">    <span class="comment">#交叉操作</span></span><br><span class="line">    new_pop = pop.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, int(pop_num / <span class="number">2</span>)):</span><br><span class="line">        new_pop[<span class="number">2</span> * i] = emper.copy()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, noPoint):</span><br><span class="line">            new_pop[<span class="number">2</span> * i][poPoint[i][j]] = new_pop[<span class="number">2</span> * i + <span class="number">1</span>][poPoint[i][j]]</span><br><span class="line">            new_pop[<span class="number">2</span> * i + <span class="number">1</span>][poPoint[i][j]] = emper[poPoint[i][j]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#变异操作</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, pop_dim):</span><br><span class="line">            choice = np.random.rand()</span><br><span class="line">            <span class="keyword">if</span> choice &lt; prob_mut:</span><br><span class="line">                <span class="keyword">if</span> pop_dim == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                        new_pop[i][j] = np.random.rand() * (x_top - x_bottom) + x_bottom</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        new_pop[i][j] = np.random.rand() * (y_top - y_bottom) + y_bottom</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_pop[i][j] = np.random.rand() * (xi_top - xi_bottom) + xi_bottom</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#子种群按照函数值升序排列</span></span><br><span class="line">    new_results = np.zeros(pop_num, dtype=float)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        new_results[i] = obj_func(func_to_cal, new_pop[i])</span><br><span class="line">    </span><br><span class="line">    new_sorted_indices = np.argsort(new_results)</span><br><span class="line">    new_results.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获得新的按照函数值升序的种群</span></span><br><span class="line">    new_sorted_pop = np.zeros((pop_num, pop_dim), dtype=float)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        new_sorted_pop[i] = new_pop[new_sorted_indices[i]].copy()</span><br><span class="line">    new_pop = new_sorted_pop.copy()</span><br><span class="line">   </span><br><span class="line">    <span class="comment">#合并两代种群并排序</span></span><br><span class="line">    <span class="comment">#函数值合并</span></span><br><span class="line">    total_results = np.hstack((results, new_results))</span><br><span class="line">    <span class="comment">#种群合并</span></span><br><span class="line">    total_pop = np.vstack((pop, new_pop))</span><br><span class="line">    <span class="comment">#获得合并后的函数值升序索引列表</span></span><br><span class="line">    total_sorted_indives = np.argsort(total_results)</span><br><span class="line">    total_results.sort()</span><br><span class="line">    <span class="comment">#将合并后的种群按升序排列</span></span><br><span class="line">    sorted_total_pop = np.zeros((pop_num * <span class="number">2</span>, pop_dim), dtype=float)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span> * pop_num):</span><br><span class="line">        sorted_total_pop[i] = total_pop[total_sorted_indives[i]].copy()</span><br><span class="line">    total_pop = sorted_total_pop.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得前一半函数值和种群</span></span><br><span class="line">    results = total_results[<span class="number">0</span>:pop_num].copy()</span><br><span class="line">    pop = total_pop[<span class="number">0</span>:pop_num].copy()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 记录本代最佳的函数值</span></span><br><span class="line">    trace[iter] = results[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p>粒子群算法的参数初始化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 种群数量</span></span><br><span class="line">pop_num = <span class="number">100</span></span><br><span class="line"><span class="comment"># 迭代次数</span></span><br><span class="line">iterations = <span class="number">50000</span></span><br><span class="line"><span class="comment"># 两个速度更新参数</span></span><br><span class="line">c1 = <span class="number">1.5</span></span><br><span class="line">c2 = <span class="number">1.5</span></span><br><span class="line"><span class="comment"># 速度变化权重</span></span><br><span class="line">w = <span class="number">0.8</span></span><br><span class="line"><span class="comment"># 根据维度设置速度上限和下限</span></span><br><span class="line"><span class="keyword">if</span> pop_dim == <span class="number">2</span>:</span><br><span class="line">    v1_max = x_top / <span class="number">2.0</span></span><br><span class="line">    v1_min = x_bottom / <span class="number">2.0</span></span><br><span class="line">    v2_max = y_top / <span class="number">2.0</span></span><br><span class="line">    v2_min = y_bottom / <span class="number">2.0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    v_max = xi_top / <span class="number">2.0</span></span><br><span class="line">    v_min = xi_bottom / <span class="number">2.0</span></span><br><span class="line"><span class="comment"># 随机初始化种群和其对应速度</span></span><br><span class="line">pop = np.random.rand(pop_num, pop_dim)</span><br><span class="line">pop_v = np.random.rand(pop_num, pop_dim)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pop_dim == <span class="number">2</span> :</span><br><span class="line">    pop[:,<span class="number">0</span>] *= (x_top - x_bottom)</span><br><span class="line">    pop[:,<span class="number">0</span>] += np.repeat(np.array([x_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line">    pop[:,<span class="number">1</span>] *= (y_top - y_bottom)</span><br><span class="line">    pop[:,<span class="number">1</span>] += np.repeat(np.array([y_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    pop_v[:,<span class="number">0</span>] *= (v1_max - v1_min)</span><br><span class="line">    pop_v[:,<span class="number">0</span>] += np.repeat(np.array([v1_min]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line">    pop_v[:,<span class="number">1</span>] *= (v2_max - v2_min)</span><br><span class="line">    pop_v[:,<span class="number">1</span>] += np.repeat(np.array([v2_min]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_dim):</span><br><span class="line">        pop[:,i] *= (xi_top - xi_bottom)</span><br><span class="line">        pop[:,i] += np.repeat(np.array([xi_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        pop_v[:,i] *= (v_max - v_min)</span><br><span class="line">        pop_v[:,i] += np.repeat(np.array([v_min]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化个体最优位置和最优值</span></span><br><span class="line">pop_best = pop.copy()</span><br><span class="line">pop_best_obj = np.zeros(pop_num)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">    pop_best_obj[i] = obj_func(func_to_cal, pop[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化全局最优位置和最优值</span></span><br><span class="line">glo_indi_best = pop[<span class="number">0</span>].copy()</span><br><span class="line">glo_indi_best_obj = np.Infinity</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据初代随机值第一次更新全局最佳位置和函数值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">    <span class="keyword">if</span> pop_best_obj[i] &lt; glo_indi_best_obj:</span><br><span class="line">        glo_indi_best = pop_best[i].copy()</span><br><span class="line">        glo_indi_best_obj = pop_best_obj[i]</span><br><span class="line"><span class="comment"># 用来记录历代最佳</span></span><br><span class="line">trace = np.zeros(iterations)</span><br></pre></td></tr></table></figure></p><p>粒子群算法的迭代过程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始迭代</span></span><br><span class="line"><span class="keyword">for</span> iter <span class="keyword">in</span> range(<span class="number">0</span>, iterations):</span><br><span class="line">    <span class="keyword">for</span> indi <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        <span class="comment"># 更新个体最优位置和最优值</span></span><br><span class="line">        <span class="keyword">if</span> obj_func(func_to_cal, pop[indi]) &lt; obj_func(func_to_cal, pop_best[indi]):</span><br><span class="line">            pop_best[indi] = pop[indi].copy()</span><br><span class="line">            pop_best_obj[indi] = obj_func(func_to_cal, pop[indi])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新全局最优位置和最优值</span></span><br><span class="line">        <span class="keyword">if</span> pop_best_obj[indi] &lt; glo_indi_best_obj:</span><br><span class="line">            glo_indi_best = pop_best[indi].copy()</span><br><span class="line">            glo_indi_best_obj = pop_best_obj[indi]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新位置和速度</span></span><br><span class="line">        pop_v[indi] = w * pop_v[indi]</span><br><span class="line">        pop_v[indi] += c1 * np.random.rand() * (pop_best[indi] - pop[indi])</span><br><span class="line">        pop_v[indi] += c2 * np.random.rand() * (glo_indi_best - pop[indi])</span><br><span class="line">        </span><br><span class="line">        pop[indi] = pop[indi] + pop_v[indi]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 边界处理</span></span><br><span class="line">        <span class="keyword">if</span> pop_dim == <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_dim):</span><br><span class="line">                <span class="keyword">if</span> pop_v[indi][i] &gt; v_max <span class="keyword">or</span> pop_v[indi][i] &lt; v_min:</span><br><span class="line">                    pop_v[indi][i] = np.random.rand() * (v_max - v_min) + v_min</span><br><span class="line">                <span class="keyword">if</span> pop[indi][i] &gt; xi_top <span class="keyword">or</span> pop[indi][i] &lt; xi_bottom:</span><br><span class="line">                    pop[indi][i] = np.random.rand() * (xi_top - xi_bottom) + xi_bottom</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pop_v[indi][<span class="number">0</span>] &gt; v1_max <span class="keyword">or</span> pop_v[indi][<span class="number">0</span>] &lt; v1_min:</span><br><span class="line">                pop_v[indi][<span class="number">0</span>] = np.random.rand() * (v1_max - v1_min) + v1_min</span><br><span class="line">            <span class="keyword">if</span> pop[indi][<span class="number">0</span>] &gt; x_top <span class="keyword">or</span> pop[indi][<span class="number">0</span>] &lt; x_bottom:</span><br><span class="line">                pop[indi][<span class="number">0</span>] = np.random.rand() * (x_top - x_bottom) + x_bottom</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> pop_v[indi][<span class="number">1</span>] &gt; v2_max <span class="keyword">or</span> pop_v[indi][<span class="number">1</span>] &lt; v2_min:</span><br><span class="line">                pop_v[indi][<span class="number">1</span>] = np.random.rand() * (v2_max - v2_min) + v2_min</span><br><span class="line">            <span class="keyword">if</span> pop[indi][<span class="number">1</span>] &gt; y_top <span class="keyword">or</span> pop[indi][<span class="number">1</span>] &lt; y_bottom:</span><br><span class="line">                pop[indi][<span class="number">1</span>] = np.random.rand() * (y_top - y_bottom) + y_bottom</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 记录本代最佳函数值</span></span><br><span class="line">    trace[iter] = glo_indi_best_obj</span><br></pre></td></tr></table></figure></p><p>差分演化算法的参数初始化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 种群数量</span></span><br><span class="line">pop_num = <span class="number">100</span></span><br><span class="line"><span class="comment"># 迭代次数</span></span><br><span class="line">iterations = <span class="number">50000</span></span><br><span class="line"><span class="comment"># 初始变异算子</span></span><br><span class="line">mut_coe_0 = <span class="number">0.4</span></span><br><span class="line"><span class="comment"># 交叉算子</span></span><br><span class="line">cro_coe = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始种群</span></span><br><span class="line">raw_pop = np.random.rand(pop_num, pop_dim)</span><br><span class="line"><span class="comment"># 变异种群</span></span><br><span class="line">mut_pop = np.zeros((pop_num, pop_dim))</span><br><span class="line"><span class="comment"># 选择种群</span></span><br><span class="line">cho_pop = np.zeros((pop_num, pop_dim))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始种群赋值</span></span><br><span class="line"><span class="keyword">if</span> pop_dim == <span class="number">2</span> :</span><br><span class="line">    raw_pop[:,<span class="number">0</span>] *= (x_top - x_bottom)</span><br><span class="line">    raw_pop[:,<span class="number">0</span>] += np.repeat(np.array([x_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line">    raw_pop[:,<span class="number">1</span>] *= (y_top - y_bottom)</span><br><span class="line">    raw_pop[:,<span class="number">1</span>] += np.repeat(np.array([y_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_dim):</span><br><span class="line">        raw_pop[:,i] *= (xi_top - xi_bottom)</span><br><span class="line">        raw_pop[:,i] += np.repeat(np.array([xi_bottom]), pop_num, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 群体的每个个体的初始目标函数值</span></span><br><span class="line">objs = np.zeros(pop_num)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">    objs[i] = obj_func(func_to_cal, raw_pop[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一代的最佳函数值(包含初始的一代)</span></span><br><span class="line">trace = np.zeros((iterations + <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 初始一代最佳函数值</span></span><br><span class="line">trace[<span class="number">0</span>] = objs.min()</span><br></pre></td></tr></table></figure></p><p>差分演化算法的迭代过程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="keyword">for</span> iter <span class="keyword">in</span> range(<span class="number">0</span>, iterations):</span><br><span class="line">    <span class="comment"># 变异</span></span><br><span class="line">    <span class="comment"># 自适应变异算子</span></span><br><span class="line">    lamda = exp(<span class="number">1.0</span> - float(iterations) / (float(iterations) - iter))</span><br><span class="line">    mut_coe = mut_coe_0 * (<span class="number">2</span> ** lamda)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> indi <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        r1 = np.random.randint(<span class="number">0</span>, pop_num)</span><br><span class="line">        <span class="keyword">while</span> r1 == indi:</span><br><span class="line">            <span class="comment"># 确保不是当前个体</span></span><br><span class="line">            r1 = np.random.randint(<span class="number">0</span>, pop_num)</span><br><span class="line">        r2 = np.random.randint(<span class="number">0</span>, pop_num)</span><br><span class="line">        <span class="keyword">while</span> r2 == indi <span class="keyword">or</span> r2 == r1:</span><br><span class="line">            <span class="comment"># 确保不是当前个体且不与r1相等</span></span><br><span class="line">            r2 = np.random.randint(<span class="number">0</span>, pop_num)</span><br><span class="line">        r3 = np.random.randint(<span class="number">0</span>, pop_num)</span><br><span class="line">        <span class="keyword">while</span> r3 == indi <span class="keyword">or</span> r3 == r1 <span class="keyword">or</span> r3 == r2:</span><br><span class="line">            <span class="comment"># 确保不是当前个体且不与r1，r2相等</span></span><br><span class="line">            r3 = np.random.randint(<span class="number">0</span>, pop_num)</span><br><span class="line">        mut_pop[indi] = raw_pop[r1] + mut_coe * (raw_pop[r2] - raw_pop[r3])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 交叉</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        <span class="comment"># 交叉点</span></span><br><span class="line">        <span class="comment"># r = np.random.randint(0, pop_dim)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_dim):</span><br><span class="line">            cro_r = np.random.rand()</span><br><span class="line">            <span class="keyword">if</span> cro_r &lt; cro_coe:</span><br><span class="line">                cho_pop[n][i] = mut_pop[n][i].copy()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cho_pop[n][i] = raw_pop[n][i].copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 边界条件处理</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        <span class="keyword">if</span> pop_dim == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> cho_pop[i][<span class="number">0</span>] &gt; x_top <span class="keyword">or</span> cho_pop[i][<span class="number">0</span>] &lt; x_bottom:</span><br><span class="line">                cho_pop[i][<span class="number">0</span>] = np.random.rand() * (x_top - x_bottom) + x_bottom</span><br><span class="line">            <span class="keyword">if</span> cho_pop[i][<span class="number">1</span>] &gt; y_top <span class="keyword">or</span> cho_pop[i][<span class="number">1</span>] &lt; y_bottom:</span><br><span class="line">                cho_pop[i][<span class="number">1</span>] = np.random.rand() * (y_top - y_bottom) + y_bottom</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, pop_dim):</span><br><span class="line">                <span class="keyword">if</span> cho_pop[i][j] &gt; xi_top <span class="keyword">or</span> cho_pop[i][j] &lt; xi_bottom:</span><br><span class="line">                    cho_pop[i][j] = np.random.rand() * (xi_top - xi_bottom) + xi_bottom</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择</span></span><br><span class="line">    <span class="comment"># 选择种群的函数值</span></span><br><span class="line">    cur_objs = np.random.rand(pop_num)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        cur_objs[i] = obj_func(func_to_cal, cho_pop[i])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果选择种群的函数值好一些就赋值给原始种群</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        <span class="keyword">if</span> cur_objs[i] &lt; objs[i]:</span><br><span class="line">            raw_pop[i] = cho_pop[i].copy()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 再重新计算原始种群的函数值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, pop_num):</span><br><span class="line">        objs[i] = obj_func(func_to_cal, raw_pop[i])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录这一代最好的函数值</span></span><br><span class="line">    trace[iter + <span class="number">1</span>] = objs.min()</span><br></pre></td></tr></table></figure></p><p>结果的输出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(trace[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 这里是绘图过程</span></span><br><span class="line">x = range(<span class="number">0</span>, iterations + <span class="number">1</span>)</span><br><span class="line">plt.scatter(x, trace)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><h2 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h2><p>如果有需要转载文章或者使用源代码，只需要在文首加上：<br>原作者：Yaron Ho<br>作者Blog：<a href="https://hoyyy.me" target="_blank" rel="noopener">https://hoyyy.me</a></p><p>十分感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文主要讲述的是解决十个无约束单目标优化问题的过程和结果，即求这些函数在给定区间内的最小值。&lt;br&gt;首先说明了用遗传算法解决的思路和结果，但
      
    
    </summary>
    
      <category term="Intelligent Optimization Algorithms" scheme="http://hoyyy.com/categories/Intelligent-Optimization-Algorithms/"/>
    
    
      <category term="Genetic Algorithm" scheme="http://hoyyy.com/tags/Genetic-Algorithm/"/>
    
      <category term="Particle Swarm Optimization" scheme="http://hoyyy.com/tags/Particle-Swarm-Optimization/"/>
    
      <category term="Differential Evolution" scheme="http://hoyyy.com/tags/Differential-Evolution/"/>
    
      <category term="Continuous Optimization" scheme="http://hoyyy.com/tags/Continuous-Optimization/"/>
    
  </entry>
  
  <entry>
    <title>快速转入Python笔记</title>
    <link href="http://hoyyy.com/2019/03/24/%E5%BF%AB%E9%80%9F%E8%BD%AC%E5%85%A5Python%E7%AC%94%E8%AE%B0/"/>
    <id>http://hoyyy.com/2019/03/24/快速转入Python笔记/</id>
    <published>2019-03-24T03:22:30.000Z</published>
    <updated>2019-04-10T15:47:16.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是一份笔记，旨在快速入门Python，阅读前提是有其他面向对象编程的经验，比如C++或者Java。所有内容只涉及Python3。全文参考《Python编程 从入门到实践》，了解详情可参考该书。</p><h2 id="变量和简单类型"><a href="#变量和简单类型" class="headerlink" title="变量和简单类型"></a>变量和简单类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印的Function，Python中不需要;结束语句</span></span><br><span class="line">print()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双引号和单引号都可以用来表示字符串</span></span><br><span class="line"><span class="string">'abc'</span>, <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#title() Method 使首字母变成大写</span></span><br><span class="line"><span class="comment">#顺便注意，Python中不需要进行显示类型声明</span></span><br><span class="line">name = <span class="string">'abc'</span></span><br><span class="line">print(name.title())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#upper() Method 使字符串全变为大写</span></span><br><span class="line">name.upper()</span><br><span class="line"><span class="comment">#lower() Method 使字符串全变为小写</span></span><br><span class="line">name.lower()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串可以直接相加</span></span><br><span class="line">name += <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串的rstrip() Method 临时性去掉末尾的空白字符</span></span><br><span class="line">name.rstrip()</span><br><span class="line"><span class="comment">#字符串的lstrip() Method 临时性去掉开头的空白字符</span></span><br><span class="line">name.lstrip()</span><br><span class="line"><span class="comment">#字符串的strip() Method 临时性去掉开头和结尾的空白字符</span></span><br><span class="line">name.strip()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在python中 ** 表示乘方</span></span><br><span class="line">age = <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">#age为9</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#str() Function 将非字符串值转化为字符串值</span></span><br><span class="line">agestr = str(<span class="number">23</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在python3中 整数 除以 整数 除不尽会得到 小数</span></span><br></pre></td></tr></table></figure><h2 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a>列表简介</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#中括号初始化，允许一个列表存不同类型的值</span></span><br><span class="line">names = [<span class="string">'Bob'</span>, <span class="string">'Jan'</span>, <span class="number">12</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#append() Method 在列表末尾添加元素</span></span><br><span class="line">names.append(<span class="string">'John'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#insert() Method 在任何位置添加新元素</span></span><br><span class="line">names.insert(<span class="number">0</span>, <span class="string">'Chris'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#del 关键字 删除给出位置的列表元素</span></span><br><span class="line"><span class="keyword">del</span> names[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pop() Method 删除列表末尾的元素，并返回删除的值</span></span><br><span class="line">poped_name = names.pop()</span><br><span class="line"><span class="comment">#pop() Method 也可以弹出任意位置的元素</span></span><br><span class="line">poped_name = names.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#remove() Method 根据值删除*第一次*出现的该元素</span></span><br><span class="line">names.remove(<span class="string">'John'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sort() Method 永久让列表升序排列</span></span><br><span class="line">names.sort()</span><br><span class="line"><span class="comment">#降序则需传递reverse参数</span></span><br><span class="line">names.sort(reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sorted() Function 临时性排序</span></span><br><span class="line">sorted(names)</span><br><span class="line"><span class="comment">#降序也需要传递reverse参数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#reverse() Method 永久性反转列表元素</span></span><br><span class="line">names.reverse()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#len() Function 获得列表长度</span></span><br><span class="line">len(names)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#任何时候都可以使用-1索引访问列表最后一个元素，除了空列表</span></span><br><span class="line">names[<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#实际上用负数会从列表尾部开始访问</span></span><br><span class="line">names[<span class="number">-2</span>]</span><br></pre></td></tr></table></figure><h2 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#for循环，传值而非引用，所有代码块靠缩进确定范围</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#range() Function 生成一系列数字，比如 1 到 8 - 1 的所有整数</span></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">pirnt(val)</span><br><span class="line"><span class="comment">#range() Function 生成列表，这个列表包含 1 到 8 - 1 的所有整数</span></span><br><span class="line">numbers = list(range(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"><span class="comment">#range() Function 制定生成数字之间的步长，下面步长是2</span></span><br><span class="line">odd_numbers = list(range(<span class="number">1</span>, <span class="number">11</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">#1, 3, 5, 7, 9</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#min() Function 返回列表最小值</span></span><br><span class="line">min(numbers)</span><br><span class="line"><span class="comment">#max() Function 返回列表最大值</span></span><br><span class="line">max(numbers)</span><br><span class="line"><span class="comment">#sum() Function 返回列表元素值总和</span></span><br><span class="line">sum(numbers)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用列表解析创建列表，下面的创建了一个 2 到 28 的所有偶数</span></span><br><span class="line">double_nums = [val * <span class="number">2</span> <span class="keyword">for</span> val <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用切片获得列表的一部分，比如下面是索引 1 到 3 - 1 的子列表</span></span><br><span class="line">sub_numbers = numbers[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">#从索引 0 到 4 - 1 的子列表</span></span><br><span class="line">sub_numbers = numbers[:<span class="number">4</span>]</span><br><span class="line"><span class="comment">#从索引 1 到最后的子列表</span></span><br><span class="line">sub_numbers = numbers[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">#最后三个的子列表</span></span><br><span class="line">sub_numbers = numbers[<span class="number">-3</span>:]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制列表需要如下：</span></span><br><span class="line">copy_numbers = Numbers[:]</span><br><span class="line"><span class="comment">#直接赋值名字是传引用</span></span><br><span class="line">refer_numbers = Numbers</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#元组是不可变的列表，用小括号初始化</span></span><br><span class="line">dimensions = (<span class="number">100</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#元组虽不可修改，但可以重新赋值</span></span><br><span class="line">dimensions = (<span class="number">120</span>, <span class="number">15</span>)</span><br><span class="line">dimensions = (<span class="number">140</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name = <span class="string">'Chris'</span>:</span><br><span class="line">print(name)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'Error'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#and, or替代了&amp;&amp; 和 ||</span></span><br><span class="line">age &gt; <span class="number">12</span> <span class="keyword">and</span> age &lt; <span class="number">20</span></span><br><span class="line">age_1 &gt; <span class="number">14</span> <span class="keyword">or</span> age_2 &gt; <span class="number">14</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#in 关键字也可以用来判断列表是否包含某值</span></span><br><span class="line">isThereACat = <span class="string">'cat'</span> <span class="keyword">in</span> animals</span><br><span class="line"><span class="comment">#加上not 就可以表否定</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'cat'</span> <span class="keyword">not</span> <span class="keyword">in</span> animals:</span><br><span class="line">print(<span class="string">'Not here'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#True 和 False 首字母大写</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#elif</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line"><span class="comment">#do somthing</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">8</span>:</span><br><span class="line"><span class="comment">#do something</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment">#do something</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表名本身作判断条件是代表其是否为空</span></span><br><span class="line"><span class="keyword">if</span> names:</span><br><span class="line">print(<span class="string">'Not Empty'</span>)</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#大括号表字典，其中value值可以在同一个字典中为各种不同类型</span></span><br><span class="line"><span class="comment">#实际上key类型也可以为几种不同的基本类型，但是像字典这种就不能作为key了</span></span><br><span class="line"><span class="comment">#而字典和列表是可以作为value的</span></span><br><span class="line">student = &#123;<span class="string">'Name'</span>:<span class="string">'Hoy'</span>, <span class="string">'Scores'</span>:<span class="number">92</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加新的键值对，直接新的键赋值就行</span></span><br><span class="line"><span class="comment">#修改值也是相同的操作</span></span><br><span class="line">student[<span class="string">'Gender'</span>] = <span class="string">'Male'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用del 关键字删除字典中元素</span></span><br><span class="line"><span class="keyword">del</span> student[<span class="string">'Gender'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#遍历字典，items() Method 返回键值对列表</span></span><br><span class="line"><span class="comment">#遍历顺序和存储顺序可能不一样</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> student.items():</span><br><span class="line">print(k, v)</span><br><span class="line"><span class="comment">#keys() Method 只返回key的列表</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> student.keys():</span><br><span class="line">print(k)</span><br><span class="line"><span class="comment">#按顺序遍历key值</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> sorted(student.keys()):</span><br><span class="line">print(k)</span><br><span class="line"><span class="comment">#values() Method 只返回value的列表</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> student.values():</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用set存储元素不重复的集合</span></span><br><span class="line"><span class="keyword">for</span> uv <span class="keyword">in</span> set(student.values()):</span><br><span class="line">print(uv)</span><br></pre></td></tr></table></figure><h2 id="用户输入和while循环"><a href="#用户输入和while循环" class="headerlink" title="用户输入和while循环"></a>用户输入和while循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#input() Function 的参数是提示信息，接下来用户输入以回车结束</span></span><br><span class="line"><span class="comment">#input() 返回的是输入的字符串</span></span><br><span class="line">message = input(<span class="string">"Please input something"</span>)</span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#int() Function 将数字的字符串表示转换为数值表示</span></span><br><span class="line"><span class="comment">#复习：与之相反的是str() Function</span></span><br><span class="line">age = input(<span class="string">"Your age"</span>)</span><br><span class="line">age = int(age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#while循环</span></span><br><span class="line">counter = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> counter &gt; <span class="number">0</span>:</span><br><span class="line"><span class="comment">#do something</span></span><br><span class="line">couter -= <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除包含特定值的所有列表元素</span></span><br><span class="line"><span class="comment">#in关键字可以作为布尔表达式</span></span><br><span class="line"><span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> pets:</span><br><span class="line">pets.remove(<span class="string">'cat'</span>)</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关键字def创建函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(num)</span>:</span></span><br><span class="line">print(<span class="string">"This is a function"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传递实参可以通过位置实参，即传统的传递方式</span></span><br><span class="line"><span class="comment">#也可以通过关键字实参，那么其位置无关紧要，如下</span></span><br><span class="line">func1(num=biggerNum)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数可以通过赋值指定默认值，实参则可以改变它</span></span><br><span class="line"><span class="comment">#指定了参数默认值的函数可以不需要提供对应实参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(age=<span class="number">18</span>)</span>:</span></span><br><span class="line">print(age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数不需要指定返回类型，可以有也可以没有return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(tag)</span>:</span></span><br><span class="line"><span class="keyword">return</span> tage + <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传递切片从而传递列表的拷贝，使函数不会改变远来的列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func4</span><span class="params">(names)</span>:</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">name += <span class="string">"'s"</span></span><br><span class="line">func4(names[:])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传递任意数量的实参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func5</span><span class="params">(*coes)</span>:</span></span><br><span class="line"><span class="keyword">for</span> coe <span class="keyword">in</span> coes:</span><br><span class="line">print(coe)</span><br><span class="line"><span class="comment">#*号创建一个名为coes的元组，所有实参都在里面</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传递未知数量未知作用的实参，通过**创建字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func6</span><span class="params">(**dic)</span>:</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</span><br><span class="line">print(k, v)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入文件，需要用点语法调用其函数</span></span><br><span class="line"><span class="keyword">import</span> filename</span><br><span class="line"><span class="comment">#或只导特定函数，不需要点语法调用这个函数</span></span><br><span class="line"><span class="keyword">from</span> filename <span class="keyword">import</span> funcname</span><br><span class="line"><span class="comment">#用as指定别名</span></span><br><span class="line"><span class="keyword">from</span> filename <span class="keyword">import</span> funcname <span class="keyword">as</span> fn</span><br><span class="line"><span class="keyword">import</span> filename <span class="keyword">as</span> f</span><br><span class="line"><span class="comment">#使用*导入所有函数，则不需要点语法调用所有函数</span></span><br><span class="line"><span class="keyword">from</span> filename <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数命名应该只有小写字母和下划线</span></span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#class关键字用来创建类，类名应该首字母大写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line"><span class="comment">#do initialization</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line"><span class="comment">#指定属性的默认值</span></span><br><span class="line">self.legs = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment">#do something</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#__init__() Method 是必不可少的</span></span><br><span class="line"><span class="comment">#初始化函数形参self是必不可少的</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#属性是在初始化方法中创建的，没有一个单独的属性列表</span></span><br><span class="line"><span class="comment">#可以通过类实例的点语法访问其属性</span></span><br><span class="line"><span class="comment">#可以通过点语法修改属性，但最好创建一个修改的方法</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#继承，括号参数里是父类</span></span><br><span class="line"><span class="comment">#初始化方法调用父类初始化方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">whiteDog</span><span class="params">(Dog)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">super().__init__(name, age)</span><br><span class="line"><span class="comment">#子类特有的属性</span></span><br><span class="line">self.color = <span class="string">'white'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重写（Override）父类的方法</span></span><br><span class="line"><span class="comment">#只需要相同的函数名再定义一次即可</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python大量的外部库可以参考</span></span><br><span class="line"><span class="comment">#Python Module of the Week</span></span><br></pre></td></tr></table></figure><h2 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#open() Function 接受一个文件名称作为参数</span></span><br><span class="line"><span class="comment">#返回一个表示该文件的对象</span></span><br><span class="line">file_obj = open(<span class="string">'bigdata.txt'</span>)</span><br><span class="line"><span class="comment">#该文件应在当前执行文件的相同文件夹内</span></span><br></pre></td></tr></table></figure><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#close() <span class="function"><span class="keyword">Method</span> 可以关闭对象所对应的文件</span></span><br><span class="line"><span class="function"><span class="title">file_obj</span>.<span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">#一定要在文件不使用之后进行关闭</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为了避免可能无法正常关闭文件，使用如下</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'bigdata.txt'</span>) <span class="keyword">as</span> file_obj:</span><br><span class="line"><span class="comment">#do something</span></span><br><span class="line"><span class="comment">#则由语言本身负责在恰当时候关闭文件</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#read() Method 以字符串形式返回文件内容</span></span><br><span class="line">contents = file_obj.read()</span><br><span class="line"><span class="comment">#在contents尾部会多一个空行，这是读到末尾返回的</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除内容末尾的空行可以使用rstrip() Method</span></span><br><span class="line">contents = contents.rstrip()</span><br><span class="line"><span class="comment">#之前提到过rstrip()是临时的</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当文件不在当前文件夹时，用绝对路径</span></span><br><span class="line">file_path = <span class="string">'/home/projects/example/bigdata.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> file_obj:</span><br><span class="line"><span class="comment">#do something</span></span><br><span class="line"><span class="comment">#在windows中/需要换成\</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#逐行读取内容</span></span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> file_obj:</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file_obj:</span><br><span class="line"><span class="comment">#do something</span></span><br><span class="line"><span class="comment">#而在上面line中都包含一个换行符，需要用rstrip() Method 删除</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#readlines() Method 返回文件对象的一个列表，每个元素是一行</span></span><br><span class="line">lines = file_obj.readlines()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以用in关键字判断某个子串是否在字符串中</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'dfs'</span> <span class="keyword">in</span> str:</span><br><span class="line"><span class="comment">#do something</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#open() Function 的默认第二个参数是'r'，也就是读模式</span></span><br><span class="line"><span class="comment">#传'w'作为第二个实参，可以写入文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'bigdata.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file_obj:</span><br><span class="line">file.obj.write(<span class="string">"writing"</span>)</span><br><span class="line"><span class="comment">#write() Method 用来写入</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果要写入的文件不存在则write() Method 会创建一个新文件</span></span><br><span class="line"><span class="comment">#如果已经存在，则会清空该文件</span></span><br><span class="line"><span class="comment">#write() 不会自动加换行符，需要自己添加</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#附加模式即第二个参数为'a'，则不会清空写入文件，而是添加到末尾</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#异常处理语法</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#do something</span></span><br><span class="line"><span class="keyword">except</span> ThisIsAnError:</span><br><span class="line"><span class="comment">#address the error</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment">#if no error do this</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#split() Method 把一个字符串按空格分开创建一个列表</span></span><br><span class="line">title = <span class="string">"make China great again"</span></span><br><span class="line">words = title.split()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pass 关键字可以让异常处理什么也不做</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入json模版来处理数据</span></span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#json.dump() Method 接受两个实参，要存储的数据以及文件对象</span></span><br><span class="line">numbers = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">file_n = <span class="string">'num.json'</span></span><br><span class="line"><span class="keyword">with</span> open(file_n) <span class="keyword">as</span> f_obj:</span><br><span class="line">json.dump(numbers, file_n)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#json.load() Method 接受文件对象作为实参</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'bigdata.txt'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">numbers = json.load(f_obj)</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#unittest模块用来进行单元测试</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用一个继承unittest.TestCase的类进行单元测试</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">formatted_name = get_formatted_name(<span class="string">'janis'</span>, <span class="string">'jopin'</span>)</span><br><span class="line">self.assertEqual(formatted_name, <span class="string">'Janis Joplin'</span>)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br><span class="line"><span class="comment">#测试类中所有test_开头的方法都会被自动运行</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试类</span></span><br><span class="line"><span class="comment">#和上面测试函数差不多</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#unittest.TestCase的setUp()方法可以重写用来只创建一次类对象</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章是一份笔记，旨在快速入门Python，阅读前提是有其他面向对象编程的经验，比如C++或者Java。所有内容只涉及Python3。全文
      
    
    </summary>
    
      <category term="Python Language" scheme="http://hoyyy.com/categories/Python-Language/"/>
    
    
      <category term="Python" scheme="http://hoyyy.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>用Python实现的遗传算法解决零一背包问题</title>
    <link href="http://hoyyy.com/2019/03/21/%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E9%9B%B6%E4%B8%80%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://hoyyy.com/2019/03/21/用Python实现的遗传算法解决零一背包问题/</id>
    <published>2019-03-21T04:28:36.000Z</published>
    <updated>2019-08-19T14:49:43.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在上智能优化技术的课程，它主要讨论的是使系统达到最优的目标的算法，通常是找到某个多变量函数的极大值或者极小值。因为在实际工程问题中，有很多目标函数没有办法用我们所学高等数学中标准的最大最小值求值方法，比如Rastrigin Function：<br><img src="Rastrigin.png" alt><br>面对这种函数传统的数学方法就显得有点无力了。</p><p>而智能优化算法就是要解决这类复杂问题。常见的智能优化算法有：遗传算法（Genetic Algorithm）、差分演化算法（Differential Evolution）、免疫算法（Immune Algorithm）、蚁群算法（Ant Colony Optimization）、粒子群算法（Particle Swarm Optimization）、模拟退火算法（Simulated Annealing）、禁忌搜索算法（Tabu Search）等等。这些算法从某些自然现象中受到启发，比如粒子群算法模拟的就是鸟类捕食的过程，鸟群成员可以通过个体间的信息交流与共享获得其他个体的发现与飞行经历。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>本文将处理的是一个经典的算法问题——零一背包问题。即给定一个背包的大小（Capacity），已知有N种不同的物品，给出它们所占的空间（Space），以及它们所对应的价值（Value），要求求出在不超过背包容量下能装下的最大的物品价值量（MaxValue）。</p><p>以前做算法题的时候了解过动态规划解决这个问题的方法，如果大家有兴趣的话在网上可以搜到相应的解决代码。我这里提供一种用Python实现遗传算法解决零一背包问题的方法。</p><h2 id="代码运行前"><a href="#代码运行前" class="headerlink" title="代码运行前"></a>代码运行前</h2><ol><li>你的电脑需要安装Python3</li><li>你需要安装Numpy</li><li>如果你想看到绘图结果你还需要安装Matplotlib</li></ol><h2 id="算法代码剖析"><a href="#算法代码剖析" class="headerlink" title="算法代码剖析"></a>算法代码剖析</h2><p>零一背包问题其实可以简化为这些物品选还是不选的问题，那么我们可以进行编码：我们创建一个物品数量大小的数组，里面只存0和1，1代表我选了这个物品，0代表没选，这个数组就是一个方案的编码，也称作染色体，其中每个0或1称作基因。而我们的种群，就是有很多的方案，每个方案，就是一个个体。</p><p>所以你要明白，我们的遗传算法一开始就是随机的给出一定数目（种群大小）的解决方案，然后让它们模拟生物进化，适应值（得到的物品价值总和）越好的就越有机会留下来。留下来的进行杂交，最后经过很多次迭代后留下的就是最好的结果了。</p><p>为了避免出现结果是局部最优，比如爬山，有很多山，当种群到达一个中等高度的山顶的时候，它们发现周围的地形都比它们的位置低了，于是就认为这是最高的了（局部最优），就安于现状不动了，觉得到达世界之颠了。实际上在周围可能还有更高的山，超出了它们的视野范围。</p><p>所以要引入变异，让有的个体随机蹦到更远的地方，它就有可能蹦到比局部最优更好的地方，在大量的迭代下就能避免其他个体安于局部最优，从而让种群向发现更高山的那个个体靠近，最后得到最好的结果。</p><p>但是要注意，智能优化算法能保证一个能让人接受的结果，但并不代表严格数学意义上的最优值。</p><p>以下是实现代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">numOfItems = <span class="number">10</span></span><br><span class="line"><span class="comment"># numOfItems = 5</span></span><br><span class="line"><span class="comment"># numOfItems = 6</span></span><br><span class="line"><span class="comment"># numOfItems = 7</span></span><br><span class="line"></span><br><span class="line">capacityOfBag = <span class="number">165</span></span><br><span class="line">spaceOfItems = [<span class="number">23</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">44</span>, <span class="number">53</span>, <span class="number">38</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">82</span>]</span><br><span class="line">valueOfItems = [<span class="number">92</span>, <span class="number">57</span>, <span class="number">49</span>, <span class="number">68</span>, <span class="number">60</span>, <span class="number">43</span>, <span class="number">67</span>, <span class="number">84</span>, <span class="number">87</span>, <span class="number">72</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># capacityOfBag = 26</span></span><br><span class="line"><span class="comment"># spaceOfItems = [12, 7, 11, 8, 9]</span></span><br><span class="line"><span class="comment"># valueOfItems = [24, 13, 23, 15, 16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># capacityOfBag = 190</span></span><br><span class="line"><span class="comment"># spaceOfItems = [56, 59, 80, 64, 75, 17]</span></span><br><span class="line"><span class="comment"># valueOfItems = [50, 50, 64, 46, 50, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># capacityOfBag = 50</span></span><br><span class="line"><span class="comment"># spaceOfItems = [31, 10, 20, 19, 4, 3, 6]</span></span><br><span class="line"><span class="comment"># valueOfItems = [70, 20, 39, 37, 7, 5, 10]</span></span><br><span class="line"></span><br><span class="line">numOfPop = <span class="number">50</span></span><br><span class="line"><span class="comment">#种群二维数组，同时随机初始化（50 x 10）</span></span><br><span class="line">population = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(numOfPop, numOfItems))</span><br><span class="line"><span class="comment">#种群适应值初始化（50）</span></span><br><span class="line">popFitness = np.zeros(numOfPop)</span><br><span class="line"><span class="comment">#交叉率</span></span><br><span class="line">crossoverRate = <span class="number">0.8</span></span><br><span class="line"><span class="comment">#变异率</span></span><br><span class="line">mutationRate = <span class="number">0.05</span></span><br><span class="line"><span class="comment">#迭代次数</span></span><br><span class="line">generations = <span class="number">100</span></span><br><span class="line"><span class="comment">#惩罚函数系数（注意如果设置太小会出现有的结果惩罚力度不够导致结果错误）</span></span><br><span class="line">punishmentCoe = <span class="number">10.0</span></span><br><span class="line"><span class="comment">#每次迭代最好记录</span></span><br><span class="line">allBest = np.zeros(generations)</span><br><span class="line"></span><br><span class="line"><span class="comment"># author: Yaron Ho</span></span><br><span class="line"><span class="comment"># blog: https://hoyyy.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#适应值函数，判断一个个体的优劣</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(gene, space, value, capacity, punish)</span>:</span></span><br><span class="line">    <span class="comment">#获取当前组合的价值总和</span></span><br><span class="line">    fit = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numOfItems):</span><br><span class="line">        fit += value[i] * gene[i]</span><br><span class="line">    <span class="comment">#获取当前组合的空间总和</span></span><br><span class="line">    size = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numOfItems):</span><br><span class="line">        size += space[i] * gene[i]</span><br><span class="line">    <span class="comment">#如果空间超出了，说明该组合是不行的，就对该算法惩罚性降低其适应值</span></span><br><span class="line">    <span class="keyword">if</span> size &gt; capacity:</span><br><span class="line">        fit -= punish * (size - capacity)</span><br><span class="line">    <span class="keyword">return</span> fit</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行迭代</span></span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> range(<span class="number">0</span>, generations):</span><br><span class="line">    <span class="comment">#计算每个个体的适应值</span></span><br><span class="line">    <span class="keyword">for</span> index, individual <span class="keyword">in</span> enumerate(population):</span><br><span class="line">        popFitness[index] = func(gene=individual, space=spaceOfItems, value=valueOfItems, capacity=capacityOfBag, punish=punishmentCoe)</span><br><span class="line">    <span class="comment">#获得种群中最高的适应值</span></span><br><span class="line">    maxFit = popFitness.max()</span><br><span class="line">    <span class="comment">#获取种群中最低的适应值</span></span><br><span class="line">    minFit = popFitness.min()</span><br><span class="line">    <span class="comment">#获得最佳个体的索引</span></span><br><span class="line">    maxIndex = np.argmax(popFitness)</span><br><span class="line">    <span class="comment">#通过索引获得最佳个体的基因序列（即组合序列）</span></span><br><span class="line">    bestIndividual = population[maxIndex]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#归一化</span></span><br><span class="line">    <span class="keyword">for</span> index, fitness <span class="keyword">in</span> enumerate(popFitness):</span><br><span class="line">        popFitness[index] = (fitness - minFit) / (maxFit - minFit)</span><br><span class="line">    </span><br><span class="line">    sumFit = popFitness.sum()</span><br><span class="line">    <span class="comment">#然后每个的优劣程度与总和的比就构成了转盘中它们所占块的大小</span></span><br><span class="line">    fitRatio = popFitness / sumFit</span><br><span class="line">    <span class="comment">#把除第一个外，每一个个体的优劣程度与之前的进行累加，那么就能形成很多连续的区间，好利于之后循环判断</span></span><br><span class="line">    fitRatio = np.cumsum(fitRatio)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#转针随机数组，大小和种群大小相同</span></span><br><span class="line">    pointer = np.random.random(numOfPop)</span><br><span class="line">    <span class="comment">#把这些转针转到的位置从小到大进行排序，就可以和对应的个体在转盘中的位置进行比较</span></span><br><span class="line">    pointer.sort()</span><br><span class="line">    <span class="comment">#初始化一个新的空种群，用来作为经选择、交叉、变异后的后一代种群</span></span><br><span class="line">    newPopulation = np.zeros((numOfPop, numOfItems), dtype=int)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#进行选择</span></span><br><span class="line">    <span class="comment">#当前要进行复制的下一代的索引</span></span><br><span class="line">    newPopIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">#前一代候选的个体的索引</span></span><br><span class="line">    fitRatioIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">#种群遍历</span></span><br><span class="line">    <span class="keyword">while</span> newPopIndex &lt; numOfPop:</span><br><span class="line">        <span class="keyword">if</span> pointer[newPopIndex] &lt; fitRatio[fitRatioIndex]:</span><br><span class="line">            newPopulation[newPopIndex] = population[fitRatioIndex]</span><br><span class="line">            newPopIndex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fitRatioIndex += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, numOfPop, <span class="number">2</span>):</span><br><span class="line">        <span class="comment">#获得一个0到1的随机小数</span></span><br><span class="line">        p = np.random.random()</span><br><span class="line">        <span class="comment">#按概率进行操作，小于我们设置的交叉概率我们才进行交叉</span></span><br><span class="line">        <span class="keyword">if</span> p &lt; crossoverRate:</span><br><span class="line">            <span class="comment">#这是一个随机获得的选择数组，如果是0，则这个位置的基因不进行交叉，1则进行交叉</span></span><br><span class="line">            crossChoice = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, numOfItems)</span><br><span class="line">            <span class="comment">#遍历当前个体的每个基因</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, numOfItems):</span><br><span class="line">                <span class="comment">#判断选择数组这个位置的值</span></span><br><span class="line">                <span class="keyword">if</span> crossChoice[j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">#这是一个标准的值交换步骤，它是当前个体与后面一个个体进行的，所以步幅长度为2</span></span><br><span class="line">                    temp = newPopulation[i][j]</span><br><span class="line">                    newPopulation[i][j] = newPopulation[i + <span class="number">1</span>][j]</span><br><span class="line">                    newPopulation[i + <span class="number">1</span>][j] = temp</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#基于概率的变异操作</span></span><br><span class="line">    <span class="comment">#遍历每个个体</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>, numOfPop):</span><br><span class="line">        <span class="comment">#遍历个体的每个基因</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, numOfItems):</span><br><span class="line">            <span class="comment">#获得一个0到1之间的随机小数</span></span><br><span class="line">            p = np.random.random()</span><br><span class="line">            <span class="comment">#如果这个小数小于我们设置的变异几率，才进行变异</span></span><br><span class="line">            <span class="keyword">if</span> p &lt; mutationRate:</span><br><span class="line">                <span class="comment">#变异很简单，就是0变1，1变0，即选择物品我不要了，没选的则选上</span></span><br><span class="line">                <span class="keyword">if</span> newPopulation[m][n] == <span class="number">0</span>:</span><br><span class="line">                    newPopulation[m][n] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    newPopulation[m][n] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    population = newPopulation.copy()</span><br><span class="line">    <span class="comment">#同时保留最优的个体在第一个位置中（万一这么好的家伙被前面的步骤搞没了呢？）</span></span><br><span class="line">    population[<span class="number">0</span>] = bestIndividual</span><br><span class="line">    <span class="comment">#同时将每代中最好的适应值存储，其最后一个也就是我们迭代结束后的最终结果</span></span><br><span class="line">    allBest[iteration] = maxFit</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出最终最好的结果</span></span><br><span class="line">print(allBest[<span class="number">-1</span>])</span><br><span class="line">print(bestIndividual)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里是绘图过程</span></span><br><span class="line">x = range(<span class="number">0</span>, generations)</span><br><span class="line">plt.scatter(x, allBest)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>得到的结果：</p><p><img src="result.png" alt></p><p>绘图跟踪每次迭代：<br><img src="graph.png" alt></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在写这个算法之前，我还从没写过Python，原本是打算用C++写的，但是我参考的是《智能优化算法及其MATLAB实例（第2版）》，里面都是Matlab实现，要用C++写出类似思想的算法真的很僵硬。而我不是很喜欢Matlab的语法，加上Matlab正版软件太贵了，学校没有购买，尽量还是不用盗版吧。早闻Numpy的大名，也听说Python不是很难，所以我用一个上午的时间查资料熟悉了一下Python的语法和Numpy的使用，粗略写下了如上算法，如果在阅读过程中有Python大佬发现我的语法不规范还请谅解。（不得不说Python的语法真是放飞自我）</p><h2 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h2><p>如果有需要转载文章或者使用源代码，只需要在文首加上：<br>原作者：Yaron Ho<br>作者Blog：<a href="https://hoyyy.me" target="_blank" rel="noopener">https://hoyyy.me</a></p><p>十分感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在上智能优化技术的课程，它主要讨论的是使系统达到最优的目标的算法，通常是找到某个多变量函数的极大值或者极小值。因为在实际工程问题中，有很
      
    
    </summary>
    
      <category term="Intelligent Optimization Algorithms" scheme="http://hoyyy.com/categories/Intelligent-Optimization-Algorithms/"/>
    
    
      <category term="Genetic Algorithm" scheme="http://hoyyy.com/tags/Genetic-Algorithm/"/>
    
      <category term="Python" scheme="http://hoyyy.com/tags/Python/"/>
    
      <category term="Discrete Optimization" scheme="http://hoyyy.com/tags/Discrete-Optimization/"/>
    
  </entry>
  
  <entry>
    <title>最终决定还是要写博客了！</title>
    <link href="http://hoyyy.com/2019/03/18/%E6%9C%80%E7%BB%88%E5%86%B3%E5%AE%9A%E8%BF%98%E6%98%AF%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86%EF%BC%81/"/>
    <id>http://hoyyy.com/2019/03/18/最终决定还是要写博客了！/</id>
    <published>2019-03-18T13:21:27.000Z</published>
    <updated>2019-03-19T00:04:59.607Z</updated>
    
    <content type="html"><![CDATA[<p>Hi! 看到这篇文章的朋友们你们好啊!</p><p>早在两年前，我加入了一个互联网团队，小组建议每个人都有自己的个人技术博客，定期更新，勉励自己多学习新知识，同时也能够为未来面向就业时有可以让别人了解自己的参考资料。</p><p>但是我当时还是大一，一来自己知识量不足，且不说建立博客这个过程了，能分享的东西也极其有限，加上自己意志力也不是很足，导致这个事情一直被拖着，写过一些东西自己又觉得没什么水平，后来就不了了之了。</p><p>过了两年之后，在学习的过程中，随着了解的东西越来越多，愈发感到它们暗中连成的庞大体系。尤其是刷leetcode和PAT过程中，很多知识的复用，以及我自己做一些小型程序或者app的时候产生的一些心得，让我特别热切地想把所有碎片都重新整理一遍，从而形成一个扎实的专业基础。</p><p>我当机立断认为到了写博客的时候了。甚至一开始我还是想用笔记本（真的是纸质的笔记本）这种传统方式去记录自己的学习历程，但是这对于我们专业来说显得太违和了……</p><p>所以在接下来的时间里，我会不定期的更新自己的经验总结，当然你会看到很多很基础的、在别的地方也能看到的东西，这是因为我还是想通过这种方式去让自己系统地、全面地去了解一些概念，而不是像以前一样抱着只要在这个地方能用，其他的我就不管的心态去学习，也就是需求驱动的学习。</p><p>我觉得一定要抱着好奇心去学习，随着兴趣去学习，感受知识背后的故事。纯粹享受知识本身所带来的那种满足好奇心的快感，也使我真正感受到，知识就是力量不是一句空话。</p><p>也祝各位看到这篇文章的朋友能实现自己的理想，生活开心！也希望我的一点微薄的努力能帮助到你！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hi! 看到这篇文章的朋友们你们好啊!&lt;/p&gt;
&lt;p&gt;早在两年前，我加入了一个互联网团队，小组建议每个人都有自己的个人技术博客，定期更新，勉励自己多学习新知识，同时也能够为未来面向就业时有可以让别人了解自己的参考资料。&lt;/p&gt;
&lt;p&gt;但是我当时还是大一，一来自己知识量不足，
      
    
    </summary>
    
      <category term="Tiktok" scheme="http://hoyyy.com/categories/Tiktok/"/>
    
    
  </entry>
  
</feed>
