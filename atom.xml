<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小贺今天有认真学习吗</title>
  
  <subtitle>昨日恍如隔世，少年砥砺向前</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hoyyy.com/"/>
  <updated>2019-03-21T07:34:53.621Z</updated>
  <id>http://hoyyy.com/</id>
  
  <author>
    <name>Christoper Hoy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用Python实现的遗传算法解决零一背包问题</title>
    <link href="http://hoyyy.com/2019/03/21/%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E9%9B%B6%E4%B8%80%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://hoyyy.com/2019/03/21/用Python实现的遗传算法解决零一背包问题/</id>
    <published>2019-03-21T04:28:36.000Z</published>
    <updated>2019-03-21T07:34:53.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在上智能优化技术的课程，它主要讨论的是使系统达到最优的目标的算法，通常是找到某个多变量函数的极大值或者极小值。因为在实际工程问题中，有很多目标函数没有办法用我们所学高等数学中标准的最大最小值求值方法，比如Rastrigin Function：<br><img src="Rastrigin.png" alt><br>面对这种函数传统的数学方法就显得有点无力了。</p><p>而智能优化算法就是要解决这类复杂问题。常见的智能优化算法有：遗传算法（Genetic Algorithm）、差分演化算法（Differential Evolution）、免疫算法（Immune Algorithm）、蚁群算法（Ant Colony Optimization）、粒子群算法（Particle Swarm Optimization）、模拟退火算法（Simulated Annealing）、禁忌搜索算法（Tabu Search）等等。这些算法从某些自然现象中受到启发，比如粒子群算法模拟的就是鸟类捕食的过程，鸟群成员可以通过个体间的信息交流与共享获得其他个体的发现与飞行经历。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>本文将处理的是一个经典的算法问题——零一背包问题。即给定一个背包的大小（Capacity），已知有N种不同的物品，给出它们所占的空间（Space），以及它们所对应的价值（Value），要求求出在不超过背包容量下能装下的最大的物品价值量（MaxValue）。</p><p>以前做算法题的时候了解过动态规划解决这个问题的方法，如果大家有兴趣的话在网上可以搜到相应的解决代码。我这里提供一种用Python实现遗传算法解决零一背包问题的方法。</p><h2 id="代码运行前"><a href="#代码运行前" class="headerlink" title="代码运行前"></a>代码运行前</h2><ol><li>你的电脑需要安装Python3</li><li>你需要安装Numpy</li><li>如果你想看到绘图结果你还需要安装Matplotlib</li></ol><h2 id="算法代码剖析"><a href="#算法代码剖析" class="headerlink" title="算法代码剖析"></a>算法代码剖析</h2><p>零一背包问题其实可以简化为这些物品选还是不选的问题，那么我们可以进行编码：我们创建一个物品数量大小的数组，里面只存0和1，1代表我选了这个物品，0代表没选，这个数组就是一个方案的编码，也称作染色体，其中每个0或1称作基因。而我们的种群，就是有很多的方案，每个方案，就是一个个体。</p><p>所以你要明白，我们的遗传算法一开始就是随机的给出一定数目（种群大小）的解决方案，然后让它们模拟生物进化，适应值（得到的物品价值总和）越好的就越有机会留下来。留下来的进行杂交，最后经过很多次迭代后留下的就是最好的结果了。</p><p>为了避免出现结果是局部最优，比如爬山，有很多山，当种群到达一个中等高度的山顶的时候，它们发现周围的地形都比它们的位置低了，于是就认为这是最高的了（局部最优），就安于现状不动了，觉得到达世界之颠了。实际上在周围可能还有更高的山，超出了它们的视野范围。</p><p>所以要引入变异，让有的个体随机蹦到更远的地方，它就有可能蹦到比局部最优更好的地方，在大量的迭代下就能避免其他个体安于局部最优，从而让种群向发现更高山的那个个体靠近，最后得到最好的结果。</p><p>但是要注意，智能优化算法能保证一个能让人接受的结果，但并不代表严格数学意义上的最优值。</p><p>以下是实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#物品件数，根据题目要求可以更改</span></span><br><span class="line">numOfItems = <span class="number">10</span></span><br><span class="line"><span class="comment">#种群规模，这是一个经验值，即经过大量实验数据性能表现较好的值，你也可以尝试自定义</span></span><br><span class="line">numOfPop = <span class="number">50</span></span><br><span class="line"><span class="comment">#种群二维数组，同时随机初始化（50 x 10）</span></span><br><span class="line">population = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=[numOfPop, numOfItems])</span><br><span class="line"><span class="comment">#种群适应值初始化（50）</span></span><br><span class="line">popFitness = np.zeros(<span class="number">50</span>)</span><br><span class="line"><span class="comment">#交叉率，这也是一个经验值，你可以自己尝试其他值</span></span><br><span class="line">crossoverRate = <span class="number">0.8</span></span><br><span class="line"><span class="comment">#变异率，这也是经验值</span></span><br><span class="line">mutationRate = <span class="number">0.05</span></span><br><span class="line"><span class="comment">#迭代次数，这也是经验值</span></span><br><span class="line">generations = <span class="number">100</span></span><br><span class="line"><span class="comment">#背包容量，根据不同题目要求不同</span></span><br><span class="line">capacityOfBag = <span class="number">165</span></span><br><span class="line"><span class="comment">#物品体积，不同题目给出不同</span></span><br><span class="line">spaceOfItems = [<span class="number">23</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">44</span>, <span class="number">53</span>, <span class="number">38</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">82</span>]</span><br><span class="line"><span class="comment">#物品价值，不同题目给出不同</span></span><br><span class="line">valueOfItems = [<span class="number">92</span>, <span class="number">57</span>, <span class="number">49</span>, <span class="number">68</span>, <span class="number">60</span>, <span class="number">43</span>, <span class="number">67</span>, <span class="number">84</span>, <span class="number">87</span>, <span class="number">72</span>]</span><br><span class="line"><span class="comment">#惩罚函数系数，经验值</span></span><br><span class="line">punishmentCoe = <span class="number">2</span></span><br><span class="line"><span class="comment">#每次迭代最好记录</span></span><br><span class="line">allBest = np.zeros(generations)</span><br><span class="line"></span><br><span class="line"><span class="comment">#author: Christoper Hoy</span></span><br><span class="line"><span class="comment">#blog: https://hoyyy.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#适应值函数，判断一个个体的优劣</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(gene, space, value, capacity, punish)</span>:</span></span><br><span class="line">    fit = <span class="number">0</span></span><br><span class="line">    <span class="comment">#获取当前组合的价值总和</span></span><br><span class="line">    <span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(value):</span><br><span class="line">        fit += val * gene[index]</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="comment">#获取当前组合的空间总和</span></span><br><span class="line">    <span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(space):</span><br><span class="line">        size += val * gene[index]</span><br><span class="line">    <span class="comment">#如果空间超出了，说明该组合是不行的，就对该算法惩罚性降低其适应值</span></span><br><span class="line">    <span class="keyword">if</span> size &gt; capacity:</span><br><span class="line">        fit -= punish * (size - capacity)</span><br><span class="line">    <span class="keyword">return</span> fit</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行迭代</span></span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> range(<span class="number">0</span>, generations):</span><br><span class="line">    <span class="comment">#计算每个个体的适应值</span></span><br><span class="line">    <span class="keyword">for</span> index, individual <span class="keyword">in</span> enumerate(population):</span><br><span class="line">        popFitness[index] = func(gene=individual, space=spaceOfItems, value=valueOfItems, capacity=capacityOfBag, punish=punishmentCoe)</span><br><span class="line">    <span class="comment">#获得种群中最高的适应值</span></span><br><span class="line">    maxFit = max(popFitness)</span><br><span class="line">    <span class="comment">#获取种群中最低的适应值</span></span><br><span class="line">    minFit = min(popFitness)</span><br><span class="line">    <span class="comment">#获得最佳个体的索引</span></span><br><span class="line">    maxIndex = np.argmax(popFitness)</span><br><span class="line">    <span class="comment">#通过索引获得最佳个体的基因序列（即组合序列）</span></span><br><span class="line">    bestIndividual = population[maxIndex]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#归一化</span></span><br><span class="line">    <span class="keyword">for</span> index, fitness <span class="keyword">in</span> enumerate(popFitness):</span><br><span class="line">        <span class="comment">#每个个体适应值在种群里优劣程度，可以转化为</span></span><br><span class="line">        <span class="comment">#它与最差的那个个体的差的大小，那么最差的那个它就是0</span></span><br><span class="line">        <span class="comment">#比如适应值分别为120，144，132，150，那么它们优劣程度就可以是0，24，12，30</span></span><br><span class="line">        <span class="comment">#而这个差与最好的那个的差的比例，就可以形成0到1之间的一个比例小数，比如这里就是0，0.8，0.4，1</span></span><br><span class="line">        popFitness[index] = (fitness - minFit) / (maxFit - minFit)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#基于轮盘赌算法进行复制</span></span><br><span class="line">    <span class="comment">#轮盘数组</span></span><br><span class="line">    <span class="comment">#将上面计算的优劣程度相加</span></span><br><span class="line">    sumFit = sum(popFitness)</span><br><span class="line">    <span class="comment">#然后每个的优劣程度与总和的比就构成了转盘中它们所占块的大小</span></span><br><span class="line">    fitRatio = popFitness / sumFit</span><br><span class="line">    <span class="comment">#把除第一个外，每一个个体的优劣程度与之前的进行累加，那么就能形成很多连续的区间，好利于之后循环判断</span></span><br><span class="line">    fitRatio = np.cumsum(fitRatio)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#转针随机数组，大小和种群大小相同，取0到1之间小数</span></span><br><span class="line">    pointer = np.random.random(numOfPop)</span><br><span class="line">    <span class="comment">#把这些转针转到的位置从小到大进行排序，就可以和对应的个体在转盘中的位置进行比较</span></span><br><span class="line">    pointer.sort()</span><br><span class="line">    <span class="comment">#初始化一个新的空种群，用来作为经选择、交叉、变异后的后一代种群</span></span><br><span class="line">    newPopulation = np.empty([numOfPop, numOfItems], int)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#进行选择</span></span><br><span class="line">    <span class="comment">#当前要进行复制的下一代的索引</span></span><br><span class="line">    newPopIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">#前一代候选的个体的索引</span></span><br><span class="line">    fitRatioIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">#种群遍历</span></span><br><span class="line">    <span class="keyword">while</span> newPopIndex &lt; numOfPop:</span><br><span class="line">        <span class="comment">#如果当前个体转针的值小于归一化并累加的数组的值，那么说明它指在这个范围内，它就被上帝选中了</span></span><br><span class="line">        <span class="keyword">if</span> pointer[newPopIndex] &lt; fitRatio[fitRatioIndex]:</span><br><span class="line">            <span class="comment">#把上一代种群这个位置的基因复制给新种群当前位置的个体</span></span><br><span class="line">            newPopulation[newPopIndex] = population[fitRatioIndex]</span><br><span class="line">            <span class="comment">#当前的位置的个体选择复制成功后，就轮到下一个位置了</span></span><br><span class="line">            newPopIndex += <span class="number">1</span></span><br><span class="line">        <span class="comment">#如果大于，则说明转针转过这个范围了，就不选择（说明它适应值占比小，处于进化劣势）</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#它被抛弃了，它的下一个个体被候选</span></span><br><span class="line">            fitRatioIndex += <span class="number">1</span></span><br><span class="line">            <span class="comment">#同一个被候选的上一代是可以被多次选择的，所以你不用担心如果被抛弃的多了会溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#基于概率的交叉操作</span></span><br><span class="line">    <span class="comment">#遍历种群，但是遍历步幅是2，也就是两个两个遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, numOfPop, <span class="number">2</span>):</span><br><span class="line">        <span class="comment">#获得一个0到1的随机小数</span></span><br><span class="line">        p = np.random.random()</span><br><span class="line">        <span class="comment">#按概率进行操作，小于我们设置的交叉概率我们才进行交叉</span></span><br><span class="line">        <span class="keyword">if</span> p &lt; crossoverRate:</span><br><span class="line">            <span class="comment">#这是一个随机获得的选择数组，如果是0，则这个位置的基因不进行交叉，1则进行交叉</span></span><br><span class="line">            crossChoice = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, numOfItems)</span><br><span class="line">            <span class="comment">#遍历当前个体的每个基因</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, numOfItems):</span><br><span class="line">                <span class="comment">#判断选择数组这个位置的值</span></span><br><span class="line">                <span class="keyword">if</span> crossChoice[j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">#这是一个标准的值交换步骤，它是当前个体与后面一个个体进行的，所以步幅长度为2</span></span><br><span class="line">                    temp = newPopulation[i][j]</span><br><span class="line">                    newPopulation[i][j] = newPopulation[i + <span class="number">1</span>][j]</span><br><span class="line">                    newPopulation[i + <span class="number">1</span>][j] = temp</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#基于概率的变异操作</span></span><br><span class="line">    <span class="comment">#遍历每个个体</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>, numOfPop):</span><br><span class="line">        <span class="comment">#遍历个体的每个基因</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, numOfItems):</span><br><span class="line">            <span class="comment">#获得一个0到1之间的随机小数</span></span><br><span class="line">            p = np.random.random()</span><br><span class="line">            <span class="comment">#如果这个小数小于我们设置的变异几率，才进行变异</span></span><br><span class="line">            <span class="keyword">if</span> p &lt; mutationRate:</span><br><span class="line">                <span class="comment">#变异很简单，就是0变1，1变0，即选择物品我不要了，没选的则选上</span></span><br><span class="line">                <span class="keyword">if</span> newPopulation[m][n] == <span class="number">0</span>:</span><br><span class="line">                    newPopulation[m][n] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    newPopulation[m][n] = <span class="number">0</span></span><br><span class="line">    <span class="comment">#前一代种群被后一代更好的种群取代</span></span><br><span class="line">    population = newPopulation</span><br><span class="line">    <span class="comment">#同时保留最优的个体在第一个位置中（万一这么好的家伙被前面的步骤搞没了呢？）</span></span><br><span class="line">    population[<span class="number">0</span>] = bestIndividual</span><br><span class="line">    <span class="comment">#同时将每代中最好的适应值存储，其最后一个也就是我们迭代结束后的最终结果</span></span><br><span class="line">    allBest[iteration] = maxFit</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出最终最好的结果</span></span><br><span class="line">print(allBest[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里是绘图过程</span></span><br><span class="line">x = range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">plt.scatter(x, allBest)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>得到的结果：</p><p><img src="result.png" alt></p><p>绘图跟踪每次迭代：<br><img src="graph.png" alt></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在写这个算法之前，我还从没写过Python，原本是打算用C++写的，但是我参考的是《智能优化算法及其MATLAB实例（第2版）》，里面都是Matlab实现，要用C++写出类似思想的算法真的很僵硬。而我不是很喜欢Matlab的语法，加上Matlab正版软件太贵了，学校没有购买，尽量还是不用盗版吧。早闻Numpy的大名，也听说Python不是很难，所以我用一个上午的时间查资料熟悉了一下Python的语法和Numpy的使用，粗略写下了如上算法，如果在阅读过程中有Python大佬发现我的语法不规范还请谅解。（不得不说Python的语法真是放飞自我）</p><h2 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h2><p>如果有需要转载文章或者使用源代码，只需要在文首加上：<br>原作者：Christoper Hoy<br>作者Blog：<a href="https://hoyyy.me" target="_blank" rel="noopener">https://hoyyy.me</a></p><p>十分感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在上智能优化技术的课程，它主要讨论的是使系统达到最优的目标的算法，通常是找到某个多变量函数的极大值或者极小值。因为在实际工程问题中，有很
      
    
    </summary>
    
      <category term="Intelligent Optimization Algorithms" scheme="http://hoyyy.com/categories/Intelligent-Optimization-Algorithms/"/>
    
    
      <category term="遗传算法" scheme="http://hoyyy.com/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    
      <category term="Python" scheme="http://hoyyy.com/tags/Python/"/>
    
      <category term="零一背包问题" scheme="http://hoyyy.com/tags/%E9%9B%B6%E4%B8%80%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最终决定还是要写博客了！</title>
    <link href="http://hoyyy.com/2019/03/18/%E6%9C%80%E7%BB%88%E5%86%B3%E5%AE%9A%E8%BF%98%E6%98%AF%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86%EF%BC%81/"/>
    <id>http://hoyyy.com/2019/03/18/最终决定还是要写博客了！/</id>
    <published>2019-03-18T13:21:27.000Z</published>
    <updated>2019-03-19T00:04:59.607Z</updated>
    
    <content type="html"><![CDATA[<p>Hi! 看到这篇文章的朋友们你们好啊!</p><p>早在两年前，我加入了一个互联网团队，小组建议每个人都有自己的个人技术博客，定期更新，勉励自己多学习新知识，同时也能够为未来面向就业时有可以让别人了解自己的参考资料。</p><p>但是我当时还是大一，一来自己知识量不足，且不说建立博客这个过程了，能分享的东西也极其有限，加上自己意志力也不是很足，导致这个事情一直被拖着，写过一些东西自己又觉得没什么水平，后来就不了了之了。</p><p>过了两年之后，在学习的过程中，随着了解的东西越来越多，愈发感到它们暗中连成的庞大体系。尤其是刷leetcode和PAT过程中，很多知识的复用，以及我自己做一些小型程序或者app的时候产生的一些心得，让我特别热切地想把所有碎片都重新整理一遍，从而形成一个扎实的专业基础。</p><p>我当机立断认为到了写博客的时候了。甚至一开始我还是想用笔记本（真的是纸质的笔记本）这种传统方式去记录自己的学习历程，但是这对于我们专业来说显得太违和了……</p><p>所以在接下来的时间里，我会不定期的更新自己的经验总结，当然你会看到很多很基础的、在别的地方也能看到的东西，这是因为我还是想通过这种方式去让自己系统地、全面地去了解一些概念，而不是像以前一样抱着只要在这个地方能用，其他的我就不管的心态去学习，也就是需求驱动的学习。</p><p>我觉得一定要抱着好奇心去学习，随着兴趣去学习，感受知识背后的故事。纯粹享受知识本身所带来的那种满足好奇心的快感，也使我真正感受到，知识就是力量不是一句空话。</p><p>也祝各位看到这篇文章的朋友能实现自己的理想，生活开心！也希望我的一点微薄的努力能帮助到你！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hi! 看到这篇文章的朋友们你们好啊!&lt;/p&gt;
&lt;p&gt;早在两年前，我加入了一个互联网团队，小组建议每个人都有自己的个人技术博客，定期更新，勉励自己多学习新知识，同时也能够为未来面向就业时有可以让别人了解自己的参考资料。&lt;/p&gt;
&lt;p&gt;但是我当时还是大一，一来自己知识量不足，
      
    
    </summary>
    
      <category term="Tiktok" scheme="http://hoyyy.com/categories/Tiktok/"/>
    
    
  </entry>
  
</feed>
